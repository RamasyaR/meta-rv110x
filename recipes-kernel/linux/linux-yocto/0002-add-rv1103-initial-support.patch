Upstream-Status: Submitted [by someone else]

diff --git a/arch/arm/boot/dts/rockchip/Makefile b/arch/arm/boot/dts/rockchip/Makefile
index ab4cd9aab..b61125b5e 100644
--- a/arch/arm/boot/dts/rockchip/Makefile
+++ b/arch/arm/boot/dts/rockchip/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 dtb-$(CONFIG_ARCH_ROCKCHIP) += \
+	rv1103g-luckfox-pico-mini.dtb \
 	rv1108-elgin-r1.dtb \
 	rv1108-evb.dtb \
 	rv1109-sonoff-ihost.dtb \
diff --git a/arch/arm/boot/dts/rockchip/rv1103-luckfox-pico-ipc.dtsi b/arch/arm/boot/dts/rockchip/rv1103-luckfox-pico-ipc.dtsi
new file mode 100755
index 000000000..0d9181146
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1103-luckfox-pico-ipc.dtsi
@@ -0,0 +1,410 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+#include "rv1106-amp.dtsi"
+
+/ {
+	chosen {
+		bootargs = "earlycon=uart8250,mmio32,0xff4c0000 console=ttyFIQ0 root=/dev/mmcblk1p7 rootwait snd_soc_core.prealloc_buffer_size_kbytes=16 coherent_pool=0";
+	};
+
+	acodec_sound: acodec-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rv-acodec";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&acodec>;
+		};
+	};
+
+	vcc_1v8: vcc-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v8";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	vcc_3v3: vcc-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_3v3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vdd_arm: vdd-arm {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_arm";
+		regulator-min-microvolt = <900000>;
+		regulator-max-microvolt = <900000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+	leds: leds {
+		compatible = "gpio-leds";
+		work_led: work{
+			gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "activity";
+			default-state = "on";
+		};
+	};
+
+	// DHT11
+	dht11_sensor {
+        compatible = "dht11";
+        pinctrl-names = "default";
+        pinctrl-0 = <&gpio1_pc7>;
+
+        dht11@1 {
+            gpios = <&gpio1 RK_PC7 GPIO_ACTIVE_HIGH>;
+            label = "dht11";
+            linux,default-trigger = "humidity";
+        };
+    };
+};
+
+/***************************** AUDIO ********************************/
+&i2s0_8ch {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&acodec {
+	#sound-dai-cells = <0>;
+	pa-ctl-gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+/***************************** CPU ********************************/
+&cpu0 {
+	cpu-supply = <&vdd_arm>;
+};
+
+/***************************** ADC ********************************/
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8>;
+};
+&tsadc {
+	status = "okay";
+};
+
+
+/***************************** USB *********************************/
+&u2phy {
+	status = "okay";
+};
+
+&u2phy_otg {
+	status = "okay";
+};
+
+&usbdrd {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	extcon = <&u2phy>;
+	status = "okay";
+};
+
+/*****************************CSI ********************************/
+&csi2_dphy_hw {
+	status = "okay";
+};
+
+&csi2_dphy0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csi_dphy_input0: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&sc3336_out>;
+				data-lanes = <1 2>;
+			};
+
+			csi_dphy_input1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&sc4336_out>;
+				data-lanes = <1 2>;
+			};
+
+			csi_dphy_input2: endpoint@2 {
+				reg = <2>;
+				remote-endpoint = <&sc530ai_out>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csi_dphy_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi_csi2_input>;
+			};
+		};
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m2_xfer>;
+
+	sc3336: sc3336@30 {
+		compatible = "smartsens,sc3336";
+		status = "okay";
+		reg = <0x30>;
+		clocks = <&cru MCLK_REF_MIPI0>;
+		clock-names = "xvclk";
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipi_refclk_out0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2119-PC1";
+		rockchip,camera-module-lens-name = "30IRC-F16";
+		port {
+			sc3336_out: endpoint {
+				remote-endpoint = <&csi_dphy_input0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	sc4336: sc4336@30 {
+		compatible = "smartsens,sc4336";
+		status = "okay";
+		reg = <0x30>;
+		clocks = <&cru MCLK_REF_MIPI0>;
+		clock-names = "xvclk";
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipi_refclk_out0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "OT01";
+		rockchip,camera-module-lens-name = "40IRC_F16";
+		port {
+			sc4336_out: endpoint {
+				remote-endpoint = <&csi_dphy_input1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	sc530ai: sc530ai@30 {
+		compatible = "smartsens,sc530ai";
+		status = "okay";
+		reg = <0x30>;
+		clocks = <&cru MCLK_REF_MIPI0>;
+		clock-names = "xvclk";
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipi_refclk_out0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2115-PC1";
+		rockchip,camera-module-lens-name = "30IRC-F16";
+		port {
+			sc530ai_out: endpoint {
+				remote-endpoint = <&csi_dphy_input2>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&mipi0_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csi_dphy_output>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in>;
+			};
+		};
+	};
+};
+
+&rkcif {
+	status = "okay";
+};
+
+&rkcif_mipi_lvds {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&mipi_pins>;
+	port {
+		/* MIPI CSI-2 endpoint */
+		cif_mipi_in: endpoint {
+			remote-endpoint = <&mipi_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds_sditf {
+	status = "okay";
+
+	port {
+		/* MIPI CSI-2 endpoint */
+		mipi_lvds_sditf: endpoint {
+			remote-endpoint = <&isp_in>;
+		};
+	};
+};
+
+&rkisp {
+	status = "okay";
+};
+
+&rkisp_vir0 {
+	status = "okay";
+
+	port@0 {
+		isp_in: endpoint {
+			remote-endpoint = <&mipi_lvds_sditf>;
+		};
+	};
+};
+
+
+/***************************** PINCTRL ********************************/
+// SPI
+&spi0 {
+	pinctrl-0 = <&spi0m0_clk &spi0m0_miso &spi0m0_mosi &spi0m0_cs0>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+  spidev@0 {
+    compatible = "rockchip,spidev";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+	};
+  fbtft@0{
+      compatible = "sitronix,st7789v";
+      reg = <0>;
+      spi-max-frequency = <20000000>;
+      fps = <30>;
+      buswidth = <8>;
+      debug = <0x7>;
+      led-gpios = <&gpio0 RK_PA4 GPIO_ACTIVE_HIGH>;//BL
+      dc-gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_HIGH>;      //DC
+      reset-gpios = <&gpio1 RK_PC3 GPIO_ACTIVE_LOW>;    //RES
+  };
+};
+// I2C
+&i2c3 {
+	pinctrl-0 = <&i2c3m1_xfer>;
+};
+&i2c0 {
+	pinctrl-0 = <&i2c0m2_xfer>;
+};
+// UART
+&uart3 {
+	pinctrl-0 = <&uart3m1_xfer>;
+};
+&uart4 {
+	pinctrl-0 = <&uart4m1_xfer>;
+};
+&uart5 {
+	pinctrl-0 = <&uart5m0_xfer>;
+};
+
+// PWM
+&pwm0 {
+	pinctrl-0 = <&pwm0m0_pins &pwm0m1_pins>;
+};
+&pwm1 {
+	pinctrl-0 = <&pwm1m0_pins>;
+};
+&pwm2 {
+	pinctrl-0 = <&pwm2m2_pins>;
+};
+&pwm3 {
+	pinctrl-0 = <&pwm3m2_pins>;
+};
+&pwm4 {
+	pinctrl-0 = <&pwm4m2_pins>;
+};
+&pwm5 {
+	pinctrl-0 = <&pwm5m2_pins>;
+};
+&pwm6 {
+	pinctrl-0 = <&pwm6m2_pins>;
+};
+&pwm8 {
+	pinctrl-0 = <&pwm8m0_pins &pwm8m1_pins>;
+};
+&pwm9 {
+	pinctrl-0 = <&pwm9m0_pins &pwm9m1_pins>;
+};
+&pwm10 {
+	pinctrl-0 = <&pwm10m0_pins &pwm10m1_pins>;
+};
+&pwm11 {
+	pinctrl-0 = <&pwm11m0_pins &pwm11m1_pins>;
+};
+
+&pinctrl {
+	spi0 {
+		spi0m0_clk: spi0m0-clk {
+			rockchip,pins = <1 RK_PC1 4 &pcfg_pull_none>;
+		};
+		spi0m0_mosi: spi0m0-mosi {
+			rockchip,pins = <1 RK_PC2 6 &pcfg_pull_none>;
+		};
+		spi0m0_miso: spi0m0-miso {
+			rockchip,pins = <1 RK_PC3 6 &pcfg_pull_none>;
+		};
+		spi0m0_cs0: spi0m0-cs0 {
+			rockchip,pins = <1 RK_PC0 4 &pcfg_pull_none>;
+		};
+	};
+
+    gpio1-pc7 {
+        gpio1_pc7:gpio1-pc7 {
+            rockchip,pins = <1 RK_PC7 RK_FUNC_GPIO &pcfg_pull_none>;
+    };
+	};
+};
diff --git a/arch/arm/boot/dts/rockchip/rv1103.dtsi b/arch/arm/boot/dts/rockchip/rv1103.dtsi
new file mode 100644
index 000000000..f86cd9eaf
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1103.dtsi
@@ -0,0 +1,59 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+
+#include "rv1106.dtsi"
+
+/ {
+	compatible = "rockchip,rv1103";
+
+	aliases {
+		/delete-property/ gpio2;
+	};
+};
+
+/delete-node/ &gpio2;
+
+&acodec {
+	compatible = "rockchip,rv1103-codec";
+};
+
+&cpu0_opp_table {
+	/delete-node/ opp-1200000000;
+	/delete-node/ opp-1296000000;
+	/delete-node/ opp-1416000000;
+	/delete-node/ opp-1512000000;
+	/delete-node/ opp-1608000000;
+};
+
+&cru {
+	assigned-clocks =
+		<&cru PLL_GPLL>, <&cru PLL_CPLL>,
+		<&cru ARMCLK>,
+		<&cru ACLK_PERI_ROOT>, <&cru HCLK_PERI_ROOT>,
+		<&cru PCLK_PERI_ROOT>, <&cru ACLK_BUS_ROOT>,
+		<&cru PCLK_TOP_ROOT>, <&cru PCLK_PMU_ROOT>,
+		<&cru HCLK_PMU_ROOT>, <&cru CLK_339M_SRC>;
+	assigned-clock-rates =
+		<1188000000>, <1000000000>,
+		<1104000000>,
+		<400000000>, <200000000>,
+		<100000000>, <300000000>,
+		<100000000>, <100000000>,
+		<200000000>, <264000000>;
+};
+
+&i2c3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3m1_xfer>;
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3m1_xfer>;
+};
+
+&u2phy_otg {
+	rockchip,vbus-always-on;
+};
diff --git a/arch/arm/boot/dts/rockchip/rv1103g-luckfox-pico-mini.dts b/arch/arm/boot/dts/rockchip/rv1103g-luckfox-pico-mini.dts
new file mode 100755
index 000000000..4c9ebba74
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1103g-luckfox-pico-mini.dts
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Luckfox Electronics Co., Ltd.
+ */
+
+/dts-v1/;
+
+#include "rv1103.dtsi"
+#include "rv1106-evb.dtsi"
+#include "rv1103-luckfox-pico-ipc.dtsi"
+
+/ {
+	model = "Luckfox Pico Mini";
+	compatible = "rockchip,rv1103g-38x38-ipc-v10", "rockchip,rv1103";
+};
+
+/**********SFC**********/
+&sfc {
+	status = "okay";
+	flash@0 {
+		compatible = "spi-nand";
+		reg = <0>;
+		spi-max-frequency = <75000000>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <1>;
+	};
+};
+
+/**********SDMMC**********/
+&sdmmc {
+	max-frequency = <50000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_clk &sdmmc0_cmd &sdmmc0_det &sdmmc0_bus4>;
+	status = "okay";
+};
+
+/**********ETH**********/
+&gmac {
+	status = "disabled";
+};
+
+/**********USB**********/
+&usbdrd_dwc3 {
+	status = "okay";
+	dr_mode = "peripheral";
+};
+
+/**********SPI**********/
+/* SPI0_M0 */
+&spi0 {
+	status = "disabled";
+	spidev@0 {
+		spi-max-frequency = <50000000>;
+	};
+};
+
+/**********I2C**********/
+/* I2C3_M1 */
+&i2c3 {
+	status = "disabled";
+	clock-frequency = <100000>;
+};
+
+/**********UART**********/
+&uart2 {
+	status = "okay";
+};
+
+/* UART3_M1 */
+&uart3 {
+	status = "disabled";
+};
+
+/* UART4_M1 */
+&uart4 {
+	status = "disabled";
+};
+
+/**********PWM**********/
+/* PWM1_M0 */
+&pwm1 {
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/rockchip/rv1106-amp.dtsi b/arch/arm/boot/dts/rockchip/rv1106-amp.dtsi
new file mode 100644
index 000000000..4edaffcaa
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1106-amp.dtsi
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+
+/ {
+	rockchip_amp: rockchip-amp {
+		compatible = "rockchip,amp";
+		clocks = <&cru CLK_TIMER_ROOT>, <&cru PCLK_TIMER>, <&cru CLK_TIMER5>,
+			<&cru CLK_CORE_MCU>, <&cru CLK_CORE_MCU_RTC>, <&cru PCLK_MAILBOX>;
+
+		status = "okay";
+	};
+};
diff --git a/arch/arm/boot/dts/rockchip/rv1106-evb.dtsi b/arch/arm/boot/dts/rockchip/rv1106-evb.dtsi
new file mode 100644
index 000000000..ca6038612
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1106-evb.dtsi
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+#include "rv1106-amp.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		poll-interval = <100>;
+		keyup-threshold-microvolt = <1800000>;
+
+		key_volumeup-key {
+			label = "key_volumeup";
+			linux,code = <KEY_VOLUMEUP>;
+			press-threshold-microvolt = <0>;
+		};
+
+		key_volumedown-key {
+			label = "key_volumedown";
+			linux,code = <KEY_VOLUMEDOWN>;
+			press-threshold-microvolt = <400781>;
+		};
+	};
+
+	restart-poweroff {
+		compatible = "restart-poweroff";
+	};
+};
+
+&fiq_debugger {
+	rockchip,irq-mode-enable = <1>;
+	status = "okay";
+};
+
+&gmac {
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&mpp_vcodec {
+	status = "okay";
+};
+
+&npu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rkdvbm {
+	status = "okay";
+};
+
+&rkvenc {
+	status = "okay";
+};
+
+&rkvenc_pp {
+	status = "okay";
+};
+
+&rmii_phy {
+	bgs,increment = <0>;
+};
+
+&rng {
+	status = "okay";
+};
+
+&rve {
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy {
+	status = "okay";
+};
+
+&u2phy_otg {
+	status = "okay";
+};
+
+&usbdrd {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	extcon = <&u2phy>;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/rockchip/rv1106-pinctrl.dtsi b/arch/arm/boot/dts/rockchip/rv1106-pinctrl.dtsi
new file mode 100644
index 000000000..3eb003103
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1106-pinctrl.dtsi
@@ -0,0 +1,1448 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/*
+ * This file is auto generated by pin2dts tool, please keep these code
+ * by adding changes at end of this file.
+ */
+&pinctrl {
+	/omit-if-no-ref/
+	pcfg_pull_up: pcfg-pull-up {
+		bias-pull-up;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_down: pcfg-pull-down {
+		bias-pull-down;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none: pcfg-pull-none {
+		bias-disable;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_1: pcfg-pull-none-drv-level-1 {
+		bias-disable;
+		drive-strength = <1>;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_2: pcfg-pull-none-drv-level-2 {
+		bias-disable;
+		drive-strength = <2>;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_3: pcfg-pull-none-drv-level-3 {
+		bias-disable;
+		drive-strength = <3>;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_drv_level_4: pcfg-pull-none-drv-level-4 {
+		bias-disable;
+		drive-strength = <4>;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_up_drv_level_2: pcfg-pull-up-drv-level-2 {
+		bias-pull-up;
+		drive-strength = <2>;
+	};
+
+	/omit-if-no-ref/
+	pcfg_pull_none_smt: pcfg-pull-none-smt {
+		bias-disable;
+		input-schmitt-enable;
+	};
+
+	adc {
+		/omit-if-no-ref/
+		adc_pins: adc-pins {
+			rockchip,pins =
+				/* adc_in0 */
+				<4 RK_PC0 1 &pcfg_pull_none>,
+				/* adc_in1 */
+				<4 RK_PC1 1 &pcfg_pull_none>;
+		};
+	};
+
+	avs {
+		/omit-if-no-ref/
+		avs_pins: avs-pins {
+			rockchip,pins =
+				/* avs_arm */
+				<1 RK_PA2 2 &pcfg_pull_none>;
+		};
+	};
+
+	clk {
+		/omit-if-no-ref/
+		clk_32k: clk-32k {
+			rockchip,pins =
+				/* clk_32k */
+				<0 RK_PA0 2 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		clk_refout: clk-refout {
+			rockchip,pins =
+				/* clk_refout */
+				<0 RK_PA0 3 &pcfg_pull_none>;
+		};
+	};
+
+	dsmaudio {
+		/omit-if-no-ref/
+		dsmaudio_pins: dsmaudio-pins {
+			rockchip,pins =
+				/* dsmaudio_n */
+				<1 RK_PD3 7 &pcfg_pull_none>,
+				/* dsmaudio_p */
+				<1 RK_PD2 7 &pcfg_pull_none>;
+		};
+	};
+
+	emmc {
+		/omit-if-no-ref/
+		emmc_bus8: emmc-bus8 {
+			rockchip,pins =
+				/* emmc_d0 */
+				<4 RK_PA4 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d1 */
+				<4 RK_PA3 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d2 */
+				<4 RK_PA2 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d3 */
+				<4 RK_PA6 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d4 */
+				<4 RK_PA5 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d5 */
+				<4 RK_PA7 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d6 */
+				<4 RK_PA1 1 &pcfg_pull_up_drv_level_2>,
+				/* emmc_d7 */
+				<4 RK_PA0 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		emmc_clk: emmc-clk {
+			rockchip,pins =
+				/* emmc_clk */
+				<4 RK_PB1 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		emmc_cmd: emmc-cmd {
+			rockchip,pins =
+				/* emmc_cmd */
+				<4 RK_PB0 1 &pcfg_pull_up_drv_level_2>;
+		};
+	};
+
+	flash {
+		/omit-if-no-ref/
+		flash_pins: flash-pins {
+			rockchip,pins =
+				/* flash_trig_out */
+				<2 RK_PA6 6 &pcfg_pull_none>;
+		};
+	};
+
+	fspi {
+		/omit-if-no-ref/
+		fspi_pins: fspi-pins {
+			rockchip,pins =
+				/* fspi_clk */
+				<4 RK_PB1 2 &pcfg_pull_up_drv_level_2>,
+				/* fspi_d0 */
+				<4 RK_PA4 2 &pcfg_pull_none>,
+				/* fspi_d1 */
+				<4 RK_PA3 2 &pcfg_pull_none>,
+				/* fspi_d2 */
+				<4 RK_PA2 2 &pcfg_pull_none>,
+				/* fspi_d3 */
+				<4 RK_PA6 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		fspi_cs0: fspi-cs0 {
+			rockchip,pins =
+				/* fspi_cs0n */
+				<4 RK_PB0 2 &pcfg_pull_up>;
+		};
+	};
+
+	hpmcu {
+		/omit-if-no-ref/
+		hpmcum0_pins: hpmcum0-pins {
+			rockchip,pins =
+				/* hpmcu_jtag_tck_m0 */
+				<1 RK_PB2 3 &pcfg_pull_none>,
+				/* hpmcu_jtag_tms_m0 */
+				<1 RK_PB3 3 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		hpmcum1_pins: hpmcum1-pins {
+			rockchip,pins =
+				/* hpmcu_jtag_tck_m1 */
+				<3 RK_PA7 4 &pcfg_pull_none>,
+				/* hpmcu_jtag_tms_m1 */
+				<3 RK_PA6 4 &pcfg_pull_none>;
+		};
+	};
+
+	i2c0 {
+		/omit-if-no-ref/
+		i2c0m0_xfer: i2c0m0-xfer {
+			rockchip,pins =
+				/* i2c0_scl_m0 */
+				<1 RK_PA3 2 &pcfg_pull_none_smt>,
+				/* i2c0_sda_m0 */
+				<1 RK_PA4 2 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c0m1_xfer: i2c0m1-xfer {
+			rockchip,pins =
+				/* i2c0_scl_m1 */
+				<4 RK_PA1 4 &pcfg_pull_none_smt>,
+				/* i2c0_sda_m1 */
+				<4 RK_PA0 4 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c0m2_xfer: i2c0m2-xfer {
+			rockchip,pins =
+				/* i2c0_scl_m2 */
+				<3 RK_PA4 3 &pcfg_pull_none_smt>,
+				/* i2c0_sda_m2 */
+				<3 RK_PA5 3 &pcfg_pull_none_smt>;
+		};
+	};
+
+	i2c1 {
+		/omit-if-no-ref/
+		i2c1m0_xfer: i2c1m0-xfer {
+			rockchip,pins =
+				/* i2c1_scl_m0 */
+				<0 RK_PA5 1 &pcfg_pull_none_smt>,
+				/* i2c1_sda_m0 */
+				<0 RK_PA6 1 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c1m1_xfer: i2c1m1-xfer {
+			rockchip,pins =
+				/* i2c1_scl_m1 */
+				<2 RK_PB0 2 &pcfg_pull_none_smt>,
+				/* i2c1_sda_m1 */
+				<2 RK_PB1 2 &pcfg_pull_none_smt>;
+		};
+	};
+
+	i2c2 {
+		/omit-if-no-ref/
+		i2c2m0_xfer: i2c2m0-xfer {
+			rockchip,pins =
+				/* i2c2_scl_m0 */
+				<1 RK_PA0 2 &pcfg_pull_none_smt>,
+				/* i2c2_sda_m0 */
+				<1 RK_PA1 2 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c2m1_xfer: i2c2m1-xfer {
+			rockchip,pins =
+				/* i2c2_scl_m1 */
+				<4 RK_PA7 4 &pcfg_pull_none_smt>,
+				/* i2c2_sda_m1 */
+				<4 RK_PA5 4 &pcfg_pull_none_smt>;
+		};
+	};
+
+	i2c3 {
+		/omit-if-no-ref/
+		i2c3m0_xfer: i2c3m0-xfer {
+			rockchip,pins =
+				/* i2c3_scl_m0 */
+				<2 RK_PA6 5 &pcfg_pull_none_smt>,
+				/* i2c3_sda_m0 */
+				<2 RK_PA7 5 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c3m1_xfer: i2c3m1-xfer {
+			rockchip,pins =
+				/* i2c3_scl_m1 */
+				<1 RK_PD3 3 &pcfg_pull_none_smt>,
+				/* i2c3_sda_m1 */
+				<1 RK_PD2 3 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c3m2_xfer: i2c3m2-xfer {
+			rockchip,pins =
+				/* i2c3_scl_m2 */
+				<3 RK_PD1 3 &pcfg_pull_none_smt>,
+				/* i2c3_sda_m2 */
+				<3 RK_PD2 3 &pcfg_pull_none_smt>;
+		};
+	};
+
+	i2c4 {
+		/omit-if-no-ref/
+		i2c4m0_xfer: i2c4m0-xfer {
+			rockchip,pins =
+				/* i2c4_scl_m0 */
+				<2 RK_PA1 5 &pcfg_pull_none_smt>,
+				/* i2c4_sda_m0 */
+				<2 RK_PA0 5 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c4m1_xfer: i2c4m1-xfer {
+			rockchip,pins =
+				/* i2c4_scl_m1 */
+				<1 RK_PC2 4 &pcfg_pull_none_smt>,
+				/* i2c4_sda_m1 */
+				<1 RK_PC3 4 &pcfg_pull_none_smt>;
+		};
+
+		/omit-if-no-ref/
+		i2c4m2_xfer: i2c4m2-xfer {
+			rockchip,pins =
+				/* i2c4_scl_m2 */
+				<3 RK_PC7 3 &pcfg_pull_none_smt>,
+				/* i2c4_sda_m2 */
+				<3 RK_PD0 3 &pcfg_pull_none_smt>;
+		};
+	};
+
+	i2s0 {
+		/omit-if-no-ref/
+		i2s0_pins: i2s0-pins {
+			rockchip,pins =
+				/* i2s0_lrck */
+				<2 RK_PA1 2 &pcfg_pull_none>,
+				/* i2s0_mclk */
+				<2 RK_PA2 2 &pcfg_pull_none>,
+				/* i2s0_sclk */
+				<2 RK_PA0 2 &pcfg_pull_none>,
+				/* i2s0_sdi0 */
+				<2 RK_PA5 2 &pcfg_pull_none>,
+				/* i2s0_sdo0 */
+				<2 RK_PA4 2 &pcfg_pull_none>,
+				/* i2s0_sdo1_sdi3 */
+				<2 RK_PA7 2 &pcfg_pull_none>,
+				/* i2s0_sdo2_sdi2 */
+				<2 RK_PA6 2 &pcfg_pull_none>,
+				/* i2s0_sdo3_sdi1 */
+				<2 RK_PA3 2 &pcfg_pull_none>;
+		};
+	};
+
+	lcd {
+		/omit-if-no-ref/
+		lcd_pins: lcd-pins {
+			rockchip,pins =
+				/* lcd_clk */
+				<1 RK_PD3 1 &pcfg_pull_none_drv_level_4>,
+				/* lcd_d0 */
+				<1 RK_PC7 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d1 */
+				<1 RK_PC6 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d2 */
+				<1 RK_PC5 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d3 */
+				<1 RK_PC4 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d4 */
+				<1 RK_PC3 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d5 */
+				<1 RK_PC2 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d6 */
+				<1 RK_PC1 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d7 */
+				<1 RK_PC0 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d8 */
+				<2 RK_PA0 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d9 */
+				<2 RK_PA1 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d10 */
+				<2 RK_PA2 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d11 */
+				<2 RK_PA3 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d12 */
+				<2 RK_PA4 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d13 */
+				<2 RK_PA5 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d14 */
+				<2 RK_PA6 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d15 */
+				<2 RK_PA7 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d16 */
+				<2 RK_PB0 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d17 */
+				<2 RK_PB1 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_den */
+				<1 RK_PD0 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_hsync */
+				<1 RK_PD1 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_vsync */
+				<1 RK_PD2 1 &pcfg_pull_none_drv_level_3>;
+		};
+	};
+
+	lpmcu {
+		/omit-if-no-ref/
+		lpmcum0_pins: lpmcum0-pins {
+			rockchip,pins =
+				/* lpmcu_jtag_tck_m0 */
+				<1 RK_PB2 4 &pcfg_pull_none>,
+				/* lpmcu_jtag_tms_m0 */
+				<1 RK_PB3 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		lpmcum1_pins: lpmcum1-pins {
+			rockchip,pins =
+				/* lpmcu_jtag_tck_m1 */
+				<3 RK_PA4 4 &pcfg_pull_none>,
+				/* lpmcu_jtag_tms_m1 */
+				<3 RK_PA5 4 &pcfg_pull_none>;
+		};
+	};
+
+	mipi {
+		/omit-if-no-ref/
+		mipi_pins: mipi-pins {
+			rockchip,pins =
+				/* mipi_lvds_ck0n */
+				<3 RK_PC0 2 &pcfg_pull_none>,
+				/* mipi_lvds_ck0p */
+				<3 RK_PC1 2 &pcfg_pull_none>,
+				/* mipi_lvds_ck1n */
+				<3 RK_PB2 2 &pcfg_pull_none>,
+				/* mipi_lvds_ck1p */
+				<3 RK_PB3 2 &pcfg_pull_none>,
+				/* mipi_lvds_d0n */
+				<3 RK_PC2 2 &pcfg_pull_none>,
+				/* mipi_lvds_d0p */
+				<3 RK_PC3 2 &pcfg_pull_none>,
+				/* mipi_lvds_d1n */
+				<3 RK_PB6 2 &pcfg_pull_none>,
+				/* mipi_lvds_d1p */
+				<3 RK_PB7 2 &pcfg_pull_none>,
+				/* mipi_lvds_d2n */
+				<3 RK_PB4 2 &pcfg_pull_none>,
+				/* mipi_lvds_d2p */
+				<3 RK_PB5 2 &pcfg_pull_none>,
+				/* mipi_lvds_d3n */
+				<3 RK_PB0 2 &pcfg_pull_none>,
+				/* mipi_lvds_d3p */
+				<3 RK_PB1 2 &pcfg_pull_none>;
+		};
+	};
+
+	pmic {
+		/omit-if-no-ref/
+		pmicm0_pins: pmicm0-pins {
+			rockchip,pins =
+				/* pmic_sleep_m0 */
+				<0 RK_PA4 1 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pmicm1_pins: pmicm1-pins {
+			rockchip,pins =
+				/* pmic_sleep_m1 */
+				<0 RK_PA3 1 &pcfg_pull_none>;
+		};
+	};
+
+	pmu {
+		/omit-if-no-ref/
+		pmu_pins: pmu-pins {
+			rockchip,pins =
+				/* pmu_debug */
+				<1 RK_PA1 3 &pcfg_pull_none>;
+		};
+	};
+
+	prelight {
+		/omit-if-no-ref/
+		prelight_pins: prelight-pins {
+			rockchip,pins =
+				/* prelight_trig_out */
+				<2 RK_PA7 6 &pcfg_pull_none>;
+		};
+	};
+
+	pwm0 {
+		/omit-if-no-ref/
+		pwm0m0_pins: pwm0m0-pins {
+			rockchip,pins =
+				/* pwm0_m0 */
+				<1 RK_PA2 1 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm0m1_pins: pwm0m1-pins {
+			rockchip,pins =
+				/* pwm0_m1 */
+				<1 RK_PD2 6 &pcfg_pull_none>;
+		};
+	};
+
+	pwm1 {
+		/omit-if-no-ref/
+		pwm1m0_pins: pwm1m0-pins {
+			rockchip,pins =
+				/* pwm1_m0 */
+				<0 RK_PA4 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm1m1_pins: pwm1m1-pins {
+			rockchip,pins =
+				/* pwm1_m1 */
+				<4 RK_PC1 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm1m2_pins: pwm1m2-pins {
+			rockchip,pins =
+				/* pwm1_m2 */
+				<3 RK_PD3 2 &pcfg_pull_none>;
+		};
+	};
+
+	pwm2 {
+		/omit-if-no-ref/
+		pwm2m0_pins: pwm2m0-pins {
+			rockchip,pins =
+				/* pwm2_m0 */
+				<0 RK_PA1 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm2m1_pins: pwm2m1-pins {
+			rockchip,pins =
+				/* pwm2_m1 */
+				<2 RK_PA6 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm2m2_pins: pwm2m2-pins {
+			rockchip,pins =
+				/* pwm2_m2 */
+				<1 RK_PC0 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm3 {
+		/omit-if-no-ref/
+		pwm3m0_pins: pwm3m0-pins {
+			rockchip,pins =
+				/* pwm3_ir_m0 */
+				<0 RK_PA2 1 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm3m1_pins: pwm3m1-pins {
+			rockchip,pins =
+				/* pwm3_ir_m1 */
+				<1 RK_PB0 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm3m2_pins: pwm3m2-pins {
+			rockchip,pins =
+				/* pwm3_ir_m2 */
+				<1 RK_PD0 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm4 {
+		/omit-if-no-ref/
+		pwm4m0_pins: pwm4m0-pins {
+			rockchip,pins =
+				/* pwm4_m0 */
+				<1 RK_PA1 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm4m1_pins: pwm4m1-pins {
+			rockchip,pins =
+				/* pwm4_m1 */
+				<2 RK_PA7 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm4m2_pins: pwm4m2-pins {
+			rockchip,pins =
+				/* pwm4_m2 */
+				<1 RK_PC1 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm5 {
+		/omit-if-no-ref/
+		pwm5m0_pins: pwm5m0-pins {
+			rockchip,pins =
+				/* pwm5_m0 */
+				<0 RK_PA5 3 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm5m1_pins: pwm5m1-pins {
+			rockchip,pins =
+				/* pwm5_m1 */
+				<2 RK_PB0 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm5m2_pins: pwm5m2-pins {
+			rockchip,pins =
+				/* pwm5_m2 */
+				<1 RK_PC2 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm6 {
+		/omit-if-no-ref/
+		pwm6m0_pins: pwm6m0-pins {
+			rockchip,pins =
+				/* pwm6_m0 */
+				<0 RK_PA6 3 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm6m1_pins: pwm6m1-pins {
+			rockchip,pins =
+				/* pwm6_m1 */
+				<2 RK_PB1 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm6m2_pins: pwm6m2-pins {
+			rockchip,pins =
+				/* pwm6_m2 */
+				<1 RK_PC3 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm7 {
+		/omit-if-no-ref/
+		pwm7m0_pins: pwm7m0-pins {
+			rockchip,pins =
+				/* pwm7_ir_m0 */
+				<1 RK_PA0 3 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm7m1_pins: pwm7m1-pins {
+			rockchip,pins =
+				/* pwm7_ir_m1 */
+				<1 RK_PB1 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm7m2_pins: pwm7m2-pins {
+			rockchip,pins =
+				/* pwm7_ir_m2 */
+				<3 RK_PC6 2 &pcfg_pull_none>;
+		};
+	};
+
+	pwm8 {
+		/omit-if-no-ref/
+		pwm8m0_pins: pwm8m0-pins {
+			rockchip,pins =
+				/* pwm8_m0 */
+				<3 RK_PA3 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm8m1_pins: pwm8m1-pins {
+			rockchip,pins =
+				/* pwm8_m1 */
+				<1 RK_PC4 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm9 {
+		/omit-if-no-ref/
+		pwm9m0_pins: pwm9m0-pins {
+			rockchip,pins =
+				/* pwm9_m0 */
+				<3 RK_PA2 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm9m1_pins: pwm9m1-pins {
+			rockchip,pins =
+				/* pwm9_m1 */
+				<1 RK_PC5 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm10 {
+		/omit-if-no-ref/
+		pwm10m0_pins: pwm10m0-pins {
+			rockchip,pins =
+				/* pwm10_m0 */
+				<3 RK_PA4 5 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm10m1_pins: pwm10m1-pins {
+			rockchip,pins =
+				/* pwm10_m1 */
+				<1 RK_PC6 3 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm10m2_pins: pwm10m2-pins {
+			rockchip,pins =
+				/* pwm10_m2 */
+				<1 RK_PD1 3 &pcfg_pull_none>;
+		};
+	};
+
+	pwm11 {
+		/omit-if-no-ref/
+		pwm11m0_pins: pwm11m0-pins {
+			rockchip,pins =
+				/* pwm11_ir_m0 */
+				<3 RK_PA5 5 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm11m1_pins: pwm11m1-pins {
+			rockchip,pins =
+				/* pwm11_ir_m1 */
+				<1 RK_PC7 3 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		pwm11m2_pins: pwm11m2-pins {
+			rockchip,pins =
+				/* pwm11_ir_m2 */
+				<1 RK_PD3 5 &pcfg_pull_none>;
+		};
+	};
+
+	rtc {
+		/omit-if-no-ref/
+		rtc_pins: rtc-pins {
+			rockchip,pins =
+				/* rtc_clko */
+				<0 RK_PA0 4 &pcfg_pull_none>;
+		};
+	};
+
+	sdmmc0 {
+		/omit-if-no-ref/
+		sdmmc0_bus4: sdmmc0-bus4 {
+			rockchip,pins =
+				/* sdmmc0_d0 */
+				<3 RK_PA3 1 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc0_d1 */
+				<3 RK_PA2 1 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc0_d2 */
+				<3 RK_PA7 1 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc0_d3 */
+				<3 RK_PA6 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc0_clk: sdmmc0-clk {
+			rockchip,pins =
+				/* sdmmc0_clk */
+				<3 RK_PA4 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc0_cmd: sdmmc0-cmd {
+			rockchip,pins =
+				/* sdmmc0_cmd */
+				<3 RK_PA5 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc0_det: sdmmc0-det {
+			rockchip,pins =
+				/* sdmmc0_det */
+				<3 RK_PA1 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc0_idle_pins: sdmmc0-idle-pins {
+			rockchip,pins =
+				<3 RK_PA2 RK_FUNC_GPIO &pcfg_pull_down>,
+				<3 RK_PA3 RK_FUNC_GPIO &pcfg_pull_down>,
+				<3 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>,
+				<3 RK_PA5 RK_FUNC_GPIO &pcfg_pull_down>,
+				<3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_down>,
+				<3 RK_PA7 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	sdmmc1 {
+		/omit-if-no-ref/
+		sdmmc1m0_bus1: sdmmc1m0-bus1 {
+			rockchip,pins =
+				/* sdmmc1_d0_m0 */
+				<2 RK_PA1 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m0_bus4: sdmmc1m0-bus4 {
+			rockchip,pins =
+				/* sdmmc1_d0_m0 */
+				<2 RK_PA1 1 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc1_d1_m0 */
+				<2 RK_PA0 1 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc1_d2_m0 */
+				<2 RK_PA5 1 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc1_d3_m0 */
+				<2 RK_PA4 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m0_clk: sdmmc1m0-clk {
+			rockchip,pins =
+				/* sdmmc1_clk_m0 */
+				<2 RK_PA2 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m0_cmd: sdmmc1m0-cmd {
+			rockchip,pins =
+				/* sdmmc1_cmd_m0 */
+				<2 RK_PA3 1 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m0_idle_pins: sdmmc1m0-idle-pins {
+			rockchip,pins =
+				<2 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA1 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA2 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA3 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>,
+				<2 RK_PA5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m1_bus4: sdmmc1m1-bus4 {
+			rockchip,pins =
+				/* sdmmc1_d0_m1 */
+				<1 RK_PC1 5 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc1_d1_m1 */
+				<1 RK_PC0 5 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc1_d2_m1 */
+				<1 RK_PC5 5 &pcfg_pull_up_drv_level_2>,
+				/* sdmmc1_d3_m1 */
+				<1 RK_PC4 5 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m1_clk: sdmmc1m1-clk {
+			rockchip,pins =
+				/* sdmmc1_clk_m1 */
+				<1 RK_PC2 5 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m1_cmd: sdmmc1m1-cmd {
+			rockchip,pins =
+				/* sdmmc1_cmd_m1 */
+				<1 RK_PC3 5 &pcfg_pull_up_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		sdmmc1m1_idle_pins: sdmmc1m1-idle-pins {
+			rockchip,pins =
+				<1 RK_PC0 RK_FUNC_GPIO &pcfg_pull_down>,
+				<1 RK_PC1 RK_FUNC_GPIO &pcfg_pull_down>,
+				<1 RK_PC2 RK_FUNC_GPIO &pcfg_pull_down>,
+				<1 RK_PC3 RK_FUNC_GPIO &pcfg_pull_down>,
+				<1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_down>,
+				<1 RK_PC5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	spi0 {
+		/omit-if-no-ref/
+		spi0m0_pins: spi0m0-pins {
+			rockchip,pins =
+				/* spi0_clk_m0 */
+				<1 RK_PC1 4 &pcfg_pull_none>,
+				/* spi0_miso_m0 */
+				<1 RK_PC3 6 &pcfg_pull_none>,
+				/* spi0_mosi_m0 */
+				<1 RK_PC2 6 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		spi0m0_cs0: spi0m0-cs0 {
+			rockchip,pins =
+				/* spi0_cs0n_m0 */
+				<1 RK_PC0 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		spi0m0_cs1: spi0m0-cs1 {
+			rockchip,pins =
+				/* spi0_cs1n_m0 */
+				<1 RK_PD2 5 &pcfg_pull_none>;
+		};
+	};
+
+	spi1 {
+		/omit-if-no-ref/
+		spi1m0_pins: spi1m0-pins {
+			rockchip,pins =
+				/* spi1_clk_m0 */
+				<4 RK_PA7 2 &pcfg_pull_none>,
+				/* spi1_miso_m0 */
+				<4 RK_PA0 2 &pcfg_pull_none>,
+				/* spi1_mosi_m0 */
+				<4 RK_PA1 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		spi1m0_cs0: spi1m0-cs0 {
+			rockchip,pins =
+				/* spi1_cs0n_m0 */
+				<4 RK_PA5 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		spi1m0_cs1: spi1m0-cs1 {
+			rockchip,pins =
+				/* spi1_cs1n_m0 */
+				<1 RK_PB1 3 &pcfg_pull_none>;
+		};
+	};
+
+	uart0 {
+		/omit-if-no-ref/
+		uart0m0_xfer: uart0m0-xfer {
+			rockchip,pins =
+				/* uart0_rx_m0 */
+				<0 RK_PA0 1 &pcfg_pull_up>,
+				/* uart0_tx_m0 */
+				<0 RK_PA1 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart0m1_xfer: uart0m1-xfer {
+			rockchip,pins =
+				/* uart0_rx_m1 */
+				<2 RK_PB0 1 &pcfg_pull_up>,
+				/* uart0_tx_m1 */
+				<2 RK_PB1 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart0m1_ctsn: uart0m1-ctsn {
+			rockchip,pins =
+				/* uart0m1_ctsn */
+				<2 RK_PA7 1 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart0m1_rtsn: uart0m1-rtsn {
+			rockchip,pins =
+				/* uart0m1_rtsn */
+				<2 RK_PA6 1 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		uart0m2_xfer: uart0m2-xfer {
+			rockchip,pins =
+				/* uart0_rx_m2 */
+				<4 RK_PA0 3 &pcfg_pull_up>,
+				/* uart0_tx_m2 */
+				<4 RK_PA1 3 &pcfg_pull_up>;
+		};
+	};
+
+	uart1 {
+		/omit-if-no-ref/
+		uart1m0_xfer: uart1m0-xfer {
+			rockchip,pins =
+				/* uart1_rx_m0 */
+				<1 RK_PA4 1 &pcfg_pull_up>,
+				/* uart1_tx_m0 */
+				<1 RK_PA3 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart1m0_ctsn: uart1m0-ctsn {
+			rockchip,pins =
+				/* uart1m0_ctsn */
+				<0 RK_PA6 2 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart1m0_rtsn: uart1m0-rtsn {
+			rockchip,pins =
+				/* uart1m0_rtsn */
+				<0 RK_PA5 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		uart1m1_xfer: uart1m1-xfer {
+			rockchip,pins =
+				/* uart1_rx_m1 */
+				<2 RK_PA5 4 &pcfg_pull_up>,
+				/* uart1_tx_m1 */
+				<2 RK_PA4 4 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart1m1_ctsn: uart1m1-ctsn {
+			rockchip,pins =
+				/* uart1m1_ctsn */
+				<2 RK_PA0 4 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart1m1_rtsn: uart1m1-rtsn {
+			rockchip,pins =
+				/* uart1m1_rtsn */
+				<2 RK_PA1 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		uart1m2_xfer: uart1m2-xfer {
+			rockchip,pins =
+				/* uart1_rx_m2 */
+				<4 RK_PA7 3 &pcfg_pull_up>,
+				/* uart1_tx_m2 */
+				<4 RK_PA5 3 &pcfg_pull_up>;
+		};
+	};
+
+	uart2 {
+		/omit-if-no-ref/
+		uart2m0_xfer: uart2m0-xfer {
+			rockchip,pins =
+				/* uart2_rx_m0 */
+				<3 RK_PA3 2 &pcfg_pull_up>,
+				/* uart2_tx_m0 */
+				<3 RK_PA2 2 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart2m1_xfer: uart2m1-xfer {
+			rockchip,pins =
+				/* uart2_rx_m1 */
+				<1 RK_PB3 2 &pcfg_pull_up>,
+				/* uart2_tx_m1 */
+				<1 RK_PB2 2 &pcfg_pull_up>;
+		};
+	};
+
+	uart3 {
+		/omit-if-no-ref/
+		uart3m0_xfer: uart3m0-xfer {
+			rockchip,pins =
+				/* uart3_rx_m0 */
+				<1 RK_PA1 1 &pcfg_pull_up>,
+				/* uart3_tx_m0 */
+				<1 RK_PA0 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart3m1_xfer: uart3m1-xfer {
+			rockchip,pins =
+				/* uart3_rx_m1 */
+				<1 RK_PD1 5 &pcfg_pull_up>,
+				/* uart3_tx_m1 */
+				<1 RK_PD0 5 &pcfg_pull_up>;
+		};
+	};
+
+	uart4 {
+		/omit-if-no-ref/
+		uart4m0_xfer: uart4m0-xfer {
+			rockchip,pins =
+				/* uart4_rx_m0 */
+				<1 RK_PB0 1 &pcfg_pull_up>,
+				/* uart4_tx_m0 */
+				<1 RK_PB1 1 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart4m1_xfer: uart4m1-xfer {
+			rockchip,pins =
+				/* uart4_rx_m1 */
+				<1 RK_PC4 4 &pcfg_pull_up>,
+				/* uart4_tx_m1 */
+				<1 RK_PC5 4 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart4m1_ctsn: uart4m1-ctsn {
+			rockchip,pins =
+				/* uart4m1_ctsn */
+				<1 RK_PC7 4 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart4m1_rtsn: uart4m1-rtsn {
+			rockchip,pins =
+				/* uart4m1_rtsn */
+				<1 RK_PC6 4 &pcfg_pull_none>;
+		};
+	};
+
+	uart5 {
+		/omit-if-no-ref/
+		uart5m0_xfer: uart5m0-xfer {
+			rockchip,pins =
+				/* uart5_rx_m0 */
+				<3 RK_PA7 2 &pcfg_pull_up>,
+				/* uart5_tx_m0 */
+				<3 RK_PA6 2 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart5m0_ctsn: uart5m0-ctsn {
+			rockchip,pins =
+				/* uart5m0_ctsn */
+				<3 RK_PA5 2 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart5m0_rtsn: uart5m0-rtsn {
+			rockchip,pins =
+				/* uart5m0_rtsn */
+				<3 RK_PA4 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		uart5m1_xfer: uart5m1-xfer {
+			rockchip,pins =
+				/* uart5_rx_m1 */
+				<1 RK_PD2 4 &pcfg_pull_up>,
+				/* uart5_tx_m1 */
+				<1 RK_PD3 4 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart5m1_ctsn: uart5m1-ctsn {
+			rockchip,pins =
+				/* uart5m1_ctsn */
+				<1 RK_PD1 4 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart5m1_rtsn: uart5m1-rtsn {
+			rockchip,pins =
+				/* uart5m1_rtsn */
+				<1 RK_PD0 4 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		uart5m2_xfer: uart5m2-xfer {
+			rockchip,pins =
+				/* uart5_rx_m2 */
+				<3 RK_PD0 2 &pcfg_pull_up>,
+				/* uart5_tx_m2 */
+				<3 RK_PC7 2 &pcfg_pull_up>;
+		};
+
+		/omit-if-no-ref/
+		uart5m2_ctsn: uart5m2-ctsn {
+			rockchip,pins =
+				/* uart5m2_ctsn */
+				<3 RK_PD2 2 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		uart5m2_rtsn: uart5m2-rtsn {
+			rockchip,pins =
+				/* uart5m2_rtsn */
+				<3 RK_PD1 2 &pcfg_pull_none>;
+		};
+	};
+
+	vicap {
+		/omit-if-no-ref/
+		vicapm0_pins: vicapm0-pins {
+			rockchip,pins =
+				/* vicap_clkin_m0 */
+				<3 RK_PC2 1 &pcfg_pull_none>,
+				/* vicap_d0_m0 */
+				<3 RK_PB0 1 &pcfg_pull_none>,
+				/* vicap_d1_m0 */
+				<3 RK_PB1 1 &pcfg_pull_none>,
+				/* vicap_d2_m0 */
+				<3 RK_PB2 1 &pcfg_pull_none>,
+				/* vicap_d3_m0 */
+				<3 RK_PB3 1 &pcfg_pull_none>,
+				/* vicap_d4_m0 */
+				<3 RK_PB4 1 &pcfg_pull_none>,
+				/* vicap_d5_m0 */
+				<3 RK_PB5 1 &pcfg_pull_none>,
+				/* vicap_d6_m0 */
+				<3 RK_PB6 1 &pcfg_pull_none>,
+				/* vicap_d7_m0 */
+				<3 RK_PB7 1 &pcfg_pull_none>,
+				/* vicap_d8_m0 */
+				<3 RK_PC0 1 &pcfg_pull_none>,
+				/* vicap_d9_m0 */
+				<3 RK_PC1 1 &pcfg_pull_none>,
+				/* vicap_hsync_m0 */
+				<3 RK_PC3 1 &pcfg_pull_none>,
+				/* vicap_vsync_m0 */
+				<3 RK_PC5 1 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		vicapm1_pins: vicapm1-pins {
+			rockchip,pins =
+				/* vicap_clkin_m1 */
+				<1 RK_PD0 2 &pcfg_pull_none>,
+				/* vicap_d0_m1 */
+				<1 RK_PA2 3 &pcfg_pull_none>,
+				/* vicap_d1_m1 */
+				<1 RK_PB1 4 &pcfg_pull_none>,
+				/* vicap_d2_m1 */
+				<1 RK_PC0 2 &pcfg_pull_none>,
+				/* vicap_d3_m1 */
+				<1 RK_PC1 2 &pcfg_pull_none>,
+				/* vicap_d4_m1 */
+				<1 RK_PC2 2 &pcfg_pull_none>,
+				/* vicap_d5_m1 */
+				<1 RK_PC3 2 &pcfg_pull_none>,
+				/* vicap_d6_m1 */
+				<1 RK_PC4 2 &pcfg_pull_none>,
+				/* vicap_d7_m1 */
+				<1 RK_PC5 2 &pcfg_pull_none>,
+				/* vicap_d8_m1 */
+				<1 RK_PC6 2 &pcfg_pull_none>,
+				/* vicap_d9_m1 */
+				<1 RK_PC7 2 &pcfg_pull_none>,
+				/* vicap_hsync_m1 */
+				<1 RK_PD1 2 &pcfg_pull_none>,
+				/* vicap_vsync_m1 */
+				<1 RK_PD2 2 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		vicap_d10: vicap-d10 {
+			rockchip,pins =
+				/* vicap_d10 */
+				<3 RK_PC6 1 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		vicap_d11: vicap-d11 {
+			rockchip,pins =
+				/* vicap_d11 */
+				<3 RK_PC7 1 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		vicap_d12: vicap-d12 {
+			rockchip,pins =
+				/* vicap_d12 */
+				<3 RK_PD0 1 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		vicap_d13: vicap-d13 {
+			rockchip,pins =
+				/* vicap_d13 */
+				<3 RK_PD1 1 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		vicap_d14: vicap-d14 {
+			rockchip,pins =
+				/* vicap_d14 */
+				<3 RK_PD2 1 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		vicap_d15: vicap-d15 {
+			rockchip,pins =
+				/* vicap_d15 */
+				<3 RK_PD3 1 &pcfg_pull_none>;
+		};
+	};
+};
+
+/*
+ * This part is edited handly.
+ */
+&pinctrl {
+	vicap {
+		/omit-if-no-ref/
+		vicap_clkout_m0: vicap-clkout-m0 {
+			rockchip,pins =
+				/* vicap_clkout_m0 */
+				<3 RK_PC4 1 &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		vicap_clkout_m1: vicap-clkout-m1 {
+			rockchip,pins =
+				/* vicap_clkout_m1 */
+				<1 RK_PD3 2 &pcfg_pull_none>;
+		};
+	};
+
+	mipi {
+		/omit-if-no-ref/
+		mipi_refclk_out0: mipi-refclk-out0 {
+			rockchip,pins =
+				/* mipi_refclk_out0 */
+				<3 RK_PC4 2 &pcfg_pull_none>;
+		};
+		/omit-if-no-ref/
+		mipi_refclk_out1: mipi-refclk-out1 {
+			rockchip,pins =
+				/* mipi_refclk_out1 */
+				<3 RK_PC6 3 &pcfg_pull_none>;
+		};
+	};
+
+	lcd {
+		/omit-if-no-ref/
+		bt1120_pins: bt1120-pins {
+			rockchip,pins =
+				/* lcd_clk */
+				<1 RK_PD3 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d0 */
+				<1 RK_PC7 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d1 */
+				<1 RK_PC6 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d2 */
+				<1 RK_PC5 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d3 */
+				<1 RK_PC4 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d4 */
+				<1 RK_PC3 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d5 */
+				<1 RK_PC2 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d6 */
+				<1 RK_PC1 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d7 */
+				<1 RK_PC0 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d8 */
+				<2 RK_PA0 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d9 */
+				<2 RK_PA1 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d10 */
+				<2 RK_PA2 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d11 */
+				<2 RK_PA3 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d12 */
+				<2 RK_PA4 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d13 */
+				<2 RK_PA5 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d14 */
+				<2 RK_PA6 3 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d15 */
+				<2 RK_PA7 3 &pcfg_pull_none_drv_level_2>;
+		};
+
+		/omit-if-no-ref/
+		bt656_pins: bt656-pins {
+			rockchip,pins =
+				/* lcd_clk */
+				<1 RK_PD3 1 &pcfg_pull_none_drv_level_2>,
+				/* lcd_d0 */
+				<1 RK_PC7 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d1 */
+				<1 RK_PC6 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d2 */
+				<1 RK_PC5 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d3 */
+				<1 RK_PC4 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d4 */
+				<1 RK_PC3 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d5 */
+				<1 RK_PC2 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d6 */
+				<1 RK_PC1 1 &pcfg_pull_none_drv_level_1>,
+				/* lcd_d7 */
+				<1 RK_PC0 1 &pcfg_pull_none_drv_level_1>;
+		};
+
+		/omit-if-no-ref/
+		rgb3x8_pins: rgb3x8-pins {
+			rockchip,pins =
+				/* lcd_clk */
+				<1 RK_PD3 1 &pcfg_pull_none_drv_level_4>,
+				/* lcd_d0 */
+				<1 RK_PC7 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d1 */
+				<1 RK_PC6 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d2 */
+				<1 RK_PC5 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d3 */
+				<1 RK_PC4 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d4 */
+				<1 RK_PC3 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d5 */
+				<1 RK_PC2 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d6 */
+				<1 RK_PC1 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d7 */
+				<1 RK_PC0 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_den */
+				<1 RK_PD0 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_hsync */
+				<1 RK_PD1 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_vsync */
+				<1 RK_PD2 1 &pcfg_pull_none_drv_level_3>;
+		};
+
+		/omit-if-no-ref/
+		rgb565_pins: rgb565-pins {
+			rockchip,pins =
+				/* lcd_clk */
+				<1 RK_PD3 1 &pcfg_pull_none_drv_level_4>,
+				/* lcd_d0 */
+				<1 RK_PC7 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d1 */
+				<1 RK_PC6 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d2 */
+				<1 RK_PC5 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d3 */
+				<1 RK_PC4 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d4 */
+				<1 RK_PC3 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d5 */
+				<1 RK_PC2 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d6 */
+				<1 RK_PC1 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d7 */
+				<1 RK_PC0 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d8 */
+				<2 RK_PA0 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d9 */
+				<2 RK_PA1 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d10 */
+				<2 RK_PA2 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d11 */
+				<2 RK_PA3 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d12 */
+				<2 RK_PA4 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d13 */
+				<2 RK_PA5 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d14 */
+				<2 RK_PA6 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_d15 */
+				<2 RK_PA7 3 &pcfg_pull_none_drv_level_3>,
+				/* lcd_den */
+				<1 RK_PD0 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_hsync */
+				<1 RK_PD1 1 &pcfg_pull_none_drv_level_3>,
+				/* lcd_vsync */
+				<1 RK_PD2 1 &pcfg_pull_none_drv_level_3>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/rockchip/rv1106.dtsi b/arch/arm/boot/dts/rockchip/rv1106.dtsi
new file mode 100644
index 000000000..c58cff3d4
--- /dev/null
+++ b/arch/arm/boot/dts/rockchip/rv1106.dtsi
@@ -0,0 +1,1497 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ */
+#include <dt-bindings/clock/rv1106-cru.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/soc/rockchip,boot-mode.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	compatible = "rockchip,rv1106";
+
+	interrupt-parent = <&gic>;
+
+	aliases {
+		csi2dphy0 = &csi2_dphy0;
+		csi2dphy1 = &csi2_dphy1;
+		csi2dphy2 = &csi2_dphy2;
+		ethernet0 = &gmac;
+		gpio0 = &gpio0;
+		gpio1 = &gpio1;
+		gpio2 = &gpio2;
+		gpio3 = &gpio3;
+		gpio4 = &gpio4;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		mmc0 = &emmc;
+		mmc1 = &sdmmc;
+		mmc2 = &sdio;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		pwm2 = &pwm2;
+		pwm3 = &pwm3;
+		pwm4 = &pwm4;
+		pwm5 = &pwm5;
+		pwm6 = &pwm6;
+		pwm7 = &pwm7;
+		pwm8 = &pwm8;
+		pwm9 = &pwm9;
+		pwm10 = &pwm10;
+		pwm11 = &pwm11;
+		rkcif_mipi_lvds0 = &rkcif_mipi_lvds;
+		rkcif_mipi_lvds1 = &rkcif_mipi_lvds1;
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		serial5 = &uart5;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		spi2 = &sfc;
+	};
+
+	clocks {
+		compatible = "simple-bus";
+
+		cpu_pvtpll: cpu-pvtpll {
+			compatible = "fixed-clock";
+			clock-frequency = <1300000000>;
+			clock-output-names = "cpu_pvtpll";
+			#clock-cells = <0>;
+			status = "disabled";
+		};
+
+		rkvenc_pvtpll: pvtpll-0 {
+			compatible = "fixed-clock";
+			clock-frequency = <410000000>;
+			clock-output-names = "clk_pvtpll_0";
+			#clock-cells = <0>;
+		};
+
+		npu_pvtpll: pvtpll-1 {
+			compatible = "fixed-clock";
+			clock-frequency = <420000000>;
+			clock-output-names = "clk_pvtpll_1";
+			#clock-cells = <0>;
+		};
+
+		xin24m: oscillator {
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			clock-output-names = "xin24m";
+			#clock-cells = <0>;
+		};
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0x0>;
+			clocks = <&cru ARMCLK>;
+			operating-points-v2 = <&cpu0_opp_table>;
+		};
+	};
+
+	cpu0_opp_table: cpu0-opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		nvmem-cells = <&cpu_leakage>;
+		nvmem-cell-names = "leakage";
+
+		rockchip,pvtpll-avg-offset = <0x4001c>;
+		rockchip,pvtpll-min-rate = <1104000>;
+		rockchip,pvtpll-volt-step = <12500>;
+		rockchip,grf = <&grf>;
+		rockchip,temp-hysteresis = <5000>;
+		rockchip,low-temp = <10000>;
+		rockchip,low-temp-min-volt = <900000>;
+
+		opp-408000000 {
+			opp-hz = /bits/ 64 <408000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-816000000 {
+			opp-hz = /bits/ 64 <816000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			clock-latency-ns = <40000>;
+			opp-suspend;
+		};
+		opp-1104000000 {
+			opp-hz = /bits/ 64 <1104000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1200000000 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <850000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1296000000 {
+			opp-hz = /bits/ 64 <1296000000>;
+			opp-microvolt = <875000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1416000000 {
+			opp-hz = /bits/ 64 <1416000000>;
+			opp-microvolt = <925000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1512000000 {
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt = <975000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+		opp-1608000000 {
+			opp-hz = /bits/ 64 <1608000000>;
+			opp-microvolt = <1000000 850000 1000000>;
+			clock-latency-ns = <40000>;
+		};
+	};
+
+	arm-pmu {
+		compatible = "arm,cortex-a7-pmu";
+		interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>;
+	};
+
+	cpuinfo {
+		compatible = "rockchip,cpuinfo";
+		nvmem-cells = <&otp_id>, <&otp_cpu_version>, <&cpu_code>;
+		nvmem-cell-names = "id", "cpu-version", "cpu-code";
+	};
+
+	/* dphy0 full mode */
+	csi2_dphy0: csi2-dphy0 {
+		compatible = "rockchip,rv1106-csi2-dphy";
+		rockchip,hw = <&csi2_dphy_hw>;
+		status = "disabled";
+	};
+
+	/* dphy1 split mode 01 */
+	csi2_dphy1: csi2-dphy1 {
+		compatible = "rockchip,rv1106-csi2-dphy";
+		rockchip,hw = <&csi2_dphy_hw>;
+		status = "disabled";
+	};
+
+	/* dphy2 split mode 23 */
+	csi2_dphy2: csi2-dphy2 {
+		compatible = "rockchip,rv1106-csi2-dphy";
+		rockchip,hw = <&csi2_dphy_hw>;
+		status = "disabled";
+	};
+
+	display_subsystem: display-subsystem {
+		compatible = "rockchip,display-subsystem";
+		ports = <&vop_out>;
+		status = "disabled";
+
+		route {
+			route_rgb: route-rgb {
+				status = "disabled";
+				logo,uboot = "logo.bmp";
+				logo,kernel = "logo_kernel.bmp";
+				logo,mode = "center";
+				charge_logo,mode = "center";
+				connect = <&vop_out_rgb>;
+			};
+		};
+	};
+
+	fiq_debugger: fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,wake-irq = <0>;
+		rockchip,irq-mode-enable = <0>;
+		rockchip,baudrate = <115200>;	/* Only 115200 and 1500000 */
+		interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+
+	firmware {
+		optee: optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+			status = "disabled";
+		};
+	};
+
+	mipi0_csi2: mipi0-csi2 {
+		compatible = "rockchip,rv1106-mipi-csi2";
+		rockchip,hw = <&mipi0_csi2_hw>, <&mipi1_csi2_hw>;
+		status = "disabled";
+	};
+
+	mipi1_csi2: mipi1-csi2 {
+		compatible = "rockchip,rv1106-mipi-csi2";
+		rockchip,hw = <&mipi0_csi2_hw>, <&mipi1_csi2_hw>;
+		status = "disabled";
+	};
+
+	mpp_srv: mpp-srv {
+		compatible = "rockchip,mpp-service";
+		rockchip,taskqueue-count = <2>;
+		status = "disabled";
+	};
+
+	mpp_vcodec: mpp-vcodec {
+		compatible = "rockchip,vcodec";
+		status = "disabled";
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	rkcif_dvp: rkcif-dvp {
+		compatible = "rockchip,rkcif-dvp";
+		rockchip,hw = <&rkcif>;
+		status = "disabled";
+	};
+
+	rkcif_dvp_sditf: rkcif-dvp-sditf {
+		compatible = "rockchip,rkcif-sditf";
+		rockchip,cif = <&rkcif_dvp>;
+		status = "disabled";
+	};
+
+	rkcif_mipi_lvds: rkcif-mipi-lvds {
+		compatible = "rockchip,rkcif-mipi-lvds";
+		rockchip,hw = <&rkcif>;
+		status = "disabled";
+	};
+
+	rkcif_mipi_lvds_sditf: rkcif-mipi-lvds-sditf {
+		compatible = "rockchip,rkcif-sditf";
+		rockchip,cif = <&rkcif_mipi_lvds>;
+		status = "disabled";
+	};
+
+	rkcif_mipi_lvds1: rkcif-mipi-lvds1 {
+		compatible = "rockchip,rkcif-mipi-lvds";
+		rockchip,hw = <&rkcif>;
+		status = "disabled";
+	};
+
+	rkcif_mipi_lvds1_sditf: rkcif-mipi-lvds1-sditf {
+		compatible = "rockchip,rkcif-sditf";
+		rockchip,cif = <&rkcif_mipi_lvds1>;
+		status = "disabled";
+	};
+
+	rkisp_vir0: rkisp-vir0 {
+		compatible = "rockchip,rkisp-vir";
+		rockchip,hw = <&rkisp>;
+		dvbm = <&rkdvbm>;
+		status = "disabled";
+	};
+
+	rkisp_vir1: rkisp-vir1 {
+		compatible = "rockchip,rkisp-vir";
+		rockchip,hw = <&rkisp>;
+		dvbm = <&rkdvbm>;
+		status = "disabled";
+	};
+
+	rkisp_vir2: rkisp-vir2 {
+		compatible = "rockchip,rkisp-vir";
+		rockchip,hw = <&rkisp>;
+		dvbm = <&rkdvbm>;
+		status = "disabled";
+	};
+
+	rkisp_vir3: rkisp-vir3 {
+		compatible = "rockchip,rkisp-vir";
+		rockchip,hw = <&rkisp>;
+		dvbm = <&rkdvbm>;
+		status = "disabled";
+	};
+
+	rockchip_system_monitor: rockchip-system-monitor {
+		compatible = "rockchip,system-monitor";
+
+		rockchip,thermal-zone = "soc-thermal";
+	};
+
+	thermal_zones: thermal-zones {
+		soc_thermal: soc-thermal {
+			polling-delay-passive = <20>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+			sustainable-power = <2100>; /* milliwatts */
+
+			thermal-sensors = <&tsadc 0>;
+			trips {
+				threshold: trip-point-0 {
+					temperature = <75000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				target: trip-point-1 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				soc_crit: soc-crit {
+					/* millicelsius */
+					temperature = <115000>;
+					/* millicelsius */
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_HIGH)>;
+		clock-frequency = <24000000>;
+	};
+
+	grf: syscon@ff000000 {
+		compatible = "rockchip,rv1106-grf", "syscon", "simple-mfd";
+		reg = <0xff000000 0x68000>;
+
+		grf_cru: grf-clock-controller {
+			compatible = "rockchip,rv1106-grf-cru";
+			#clock-cells = <1>;
+		};
+
+		reboot_mode: reboot-mode {
+			compatible = "syscon-reboot-mode";
+			offset = <0x20200>;
+			mode-fastboot = <BOOT_FASTBOOT>;
+			mode-loader = <BOOT_BL_DOWNLOAD>;
+			mode-normal = <BOOT_NORMAL>;
+			mode-recovery = <BOOT_RECOVERY>;
+		};
+
+		rgb: rgb {
+			compatible = "rockchip,rv1106-rgb";
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					rgb_in_vop: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&vop_out_rgb>;
+					};
+				};
+			};
+		};
+
+		rknpor_powergood: rknpor-powergood {
+			compatible = "rockchip,rv1106-npor-powergood";
+			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
+			status = "okay";
+		};
+	};
+
+	rtc: rtc@ff1c0000 {
+		compatible = "rockchip,rv1106-rtc";
+		reg = <0xff1c0000 0x1000>;
+		rockchip,grf = <&grf>;
+		interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_VI_RTC_PHY>, <&cru PCLK_VI_RTC_TEST>;
+		clock-names = "pclk_phy", "pclk_test";
+		assigned-clocks = <&cru PCLK_VI_RTC_PHY>;
+		assigned-clock-rates = <24000000>;
+		status = "disabled";
+	};
+
+	gic: interrupt-controller@ff1f0000 {
+		compatible = "arm,gic-400";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		#address-cells = <0>;
+
+		reg = <0xff1f1000 0x1000>,
+		      <0xff1f2000 0x2000>,
+		      <0xff1f4000 0x2000>,
+		      <0xff1f6000 0x2000>;
+		interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	arm-debug@ff200000 {
+		compatible = "rockchip,debug";
+		reg = <0xff200000 0x1000>;
+	};
+
+	pvtm@ff240000 {
+		compatible = "rockchip,rv1106-core-pvtm";
+		reg = <0xff240000 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		pvtm@0 {
+			reg = <0>;
+			clocks = <&cru CLK_PVTM_CORE>;
+			clock-names = "clk";
+			resets = <&cru SRST_PVTM_CORE>, <&cru SRST_P_PVTM_CORE>;
+			reset-names = "rst", "rst-p";
+		};
+	};
+
+	i2c0: i2c@ff310000 {
+		compatible = "rockchip,rv1106-i2c", "rockchip,rk3399-i2c";
+		reg = <0xff310000 0x1000>;
+		interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_I2C0>, <&cru PCLK_I2C0>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c0m0_xfer>;
+		status = "disabled";
+	};
+
+	i2c1: i2c@ff320000 {
+		compatible = "rockchip,rv1106-i2c", "rockchip,rk3399-i2c";
+		reg = <0xff320000 0x1000>;
+		interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_I2C1>, <&cru PCLK_I2C1>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1m0_xfer>;
+		status = "disabled";
+	};
+
+	dsm: codec-digital@ff340000 {
+		compatible = "rockchip,rv1106-codec-digital", "rockchip,codec-digital-v1";
+		reg = <0xff340000 0x1000>;
+		clocks = <&cru MCLK_DSM>, <&cru PCLK_DSM>;
+		clock-names = "dac", "pclk";
+		resets = <&cru SRST_M_DSM>;
+		reset-names = "reset" ;
+		rockchip,grf = <&grf>;
+		rockchip,pwm-output-mode;
+		#sound-dai-cells = <0>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsmaudio_pins>;
+		status = "disabled";
+	};
+
+	pwm0: pwm@ff350000 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff350000 0x10>;
+		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm0m0_pins>;
+		clocks = <&cru CLK_PWM0_PERI>, <&cru PCLK_PWM0_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm1: pwm@ff350010 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff350010 0x10>;
+		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm1m0_pins>;
+		clocks = <&cru CLK_PWM0_PERI>, <&cru PCLK_PWM0_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm2: pwm@ff350020 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff350020 0x10>;
+		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm2m0_pins>;
+		clocks = <&cru CLK_PWM0_PERI>, <&cru PCLK_PWM0_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm3: pwm@ff350030 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff350030 0x10>;
+		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm3m0_pins>;
+		clocks = <&cru CLK_PWM0_PERI>, <&cru PCLK_PWM0_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm4: pwm@ff360000 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff360000 0x10>;
+		interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm4m0_pins>;
+		clocks = <&cru CLK_PWM1_PERI>, <&cru PCLK_PWM1_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm5: pwm@ff360010 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff360010 0x10>;
+		interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm5m0_pins>;
+		clocks = <&cru CLK_PWM1_PERI>, <&cru PCLK_PWM1_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm6: pwm@ff360020 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff360020 0x10>;
+		interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm6m0_pins>;
+		clocks = <&cru CLK_PWM1_PERI>, <&cru PCLK_PWM1_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm7: pwm@ff360030 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff360030 0x10>;
+		interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm7m0_pins>;
+		clocks = <&cru CLK_PWM1_PERI>, <&cru PCLK_PWM1_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pmu_mailbox: mailbox@ff378000 {
+		compatible = "rockchip,rv1106-mailbox",
+			     "rockchip,rk3368-mailbox";
+		reg = <0xff378000 0x200>;
+		interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_PMU_MAILBOX>;
+		clock-names = "pclk_mailbox";
+		#mbox-cells = <1>;
+		status = "disabled";
+	};
+
+	pmuioc: syscon@ff388000 {
+		compatible = "rockchip,rv1106-pmuioc", "syscon";
+		reg = <0xff388000 0x1000>;
+	};
+
+	pvtm@ff390000 {
+		compatible = "rockchip,rv1106-pmu-pvtm";
+		reg = <0xff390000 0x100>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		pvtm@0 {
+			reg = <1>;
+			clocks = <&cru CLK_PVTM_PMU>, <&cru PCLK_PVTM_PMU>;
+			clock-names = "clk", "pclk";
+			resets = <&cru SRST_PVTM_PMU>, <&cru SRST_P_PVTM_PMU>;
+			reset-names = "rst", "rst-p";
+		};
+	};
+
+	cru: clock-controller@ff3a0000 {
+		compatible = "rockchip,rv1106-cru";
+		reg = <0xff3a0000 0x20000>;
+		rockchip,grf = <&grf>;
+		#clock-cells = <1>;
+		#reset-cells = <1>;
+
+		assigned-clocks =
+			<&cru PLL_GPLL>, <&cru PLL_CPLL>,
+			<&cru ARMCLK>,
+			<&cru ACLK_PERI_ROOT>, <&cru HCLK_PERI_ROOT>,
+			<&cru PCLK_PERI_ROOT>, <&cru ACLK_BUS_ROOT>,
+			<&cru PCLK_TOP_ROOT>, <&cru PCLK_PMU_ROOT>,
+			<&cru HCLK_PMU_ROOT>;
+		assigned-clock-rates =
+			<1188000000>, <1000000000>,
+			<1104000000>,
+			<400000000>, <200000000>,
+			<100000000>, <300000000>,
+			<100000000>, <100000000>,
+			<200000000>;
+	};
+
+	saradc: saradc@ff3c0000 {
+		compatible = "rockchip,rv1106-saradc";
+		reg = <0xff3c0000 0x200>;
+		interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+		#io-channel-cells = <1>;
+		clocks = <&cru CLK_SARADC>, <&cru PCLK_SARADC>;
+		clock-names = "saradc", "apb_pclk";
+		resets = <&cru SRST_P_SARADC>;
+		reset-names = "saradc-apb";
+		status = "disabled";
+	};
+
+	tsadc: tsadc@ff3c8000 {
+		compatible = "rockchip,rv1106-tsadc";
+		reg = <0xff3c8000 0x1000>;
+		rockchip,grf = <&grf>;
+		interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru CLK_TSADC>, <&cru PCLK_TSADC>, <&cru CLK_TSADC_TSEN>;
+		clock-names = "tsadc", "apb_pclk", "tsen";
+		assigned-clocks = <&cru CLK_TSADC>, <&cru CLK_TSADC_TSEN>;
+		assigned-clock-rates = <1000000>, <12000000>;
+		resets = <&cru SRST_TSADC>, <&cru SRST_P_TSADC>;
+		reset-names = "tsadc", "tsadc-apb";
+		#thermal-sensor-cells = <1>;
+		rockchip,hw-tshut-temp = <120000>;
+		rockchip,hw-tshut-mode = <0>; /* tshut mode 0:CRU 1:GPIO */
+		rockchip,hw-tshut-polarity = <0>; /* tshut polarity 0:LOW 1:HIGH */
+		status = "disabled";
+	};
+
+	otp: otp@ff3d0000 {
+		compatible = "rockchip,rv1106-otp";
+		reg = <0xff3d0000 0x4000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		clocks = <&cru CLK_USER_OTPC_NS>, <&cru CLK_SBPI_OTPC_NS>,
+			 <&cru PCLK_OTPC_NS>, <&cru PCLK_OTP_MASK>,
+			 <&cru CLK_OTPC_ARB>, <&cru CLK_PMC_OTP>;
+		clock-names = "usr", "sbpi", "apb", "phy", "arb", "pmc";
+		resets = <&cru SRST_USER_OTPC_NS>, <&cru SRST_SBPI_OTPC_NS>,
+			 <&cru SRST_P_OTPC_NS>, <&cru SRST_P_OTP_MASK>,
+			 <&cru SRST_OTPC_ARB>, <&cru SRST_PMC_OTP>;
+		reset-names = "usr", "sbpi", "apb", "phy", "arb", "pmc";
+
+		/* Data cells */
+		cpu_code: cpu-code@2 {
+			reg = <0x02 0x2>;
+		};
+		otp_cpu_version: cpu-version@8 {
+			reg = <0x08 0x1>;
+			bits = <3 3>;
+		};
+		otp_id: id@a {
+			reg = <0x0a 0x10>;
+		};
+		cpu_leakage: cpu-leakage@1a {
+			reg = <0x1a 0x1>;
+		};
+		log_leakage: log-leakage@1b {
+			reg = <0x1b 0x1>;
+		};
+		macphy_bgs: macphy-bgs@2d {
+			reg = <0x2d 0x1>;
+		};
+		macphy_txlevel: macphy-txlevel@2e {
+			reg = <0x2e 0x2>;
+		};
+	};
+
+	u2phy: usb2-phy@ff3e0000 {
+		compatible = "rockchip,rv1106-usb2phy";
+		reg = <0xff3e0000 0x8000>;
+		rockchip,usbgrf = <&grf>;
+		clocks = <&cru CLK_REF_USBPHY>, <&cru PCLK_USBPHY>;
+		clock-names = "phyclk", "pclk";
+		resets = <&cru SRST_USBPHY_POR>, <&cru SRST_P_USBPHY>;
+		reset-names = "u2phy", "u2phy-apb";
+		#clock-cells = <0>;
+		status = "disabled";
+
+		u2phy_otg: otg-port {
+			#phy-cells = <0>;
+			interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "otg-bvalid", "otg-id",
+					  "linestate", "disconnect";
+			status = "disabled";
+		};
+	};
+
+	csi2_dphy_hw: csi2-dphy-hw@ff3e8000 {
+		compatible = "rockchip,rv1106-csi2-dphy-hw";
+		reg = <0xff3e8000 0x8000>;
+		clocks = <&cru PCLK_MIPICSIPHY>;
+		clock-names = "pclk";
+		resets = <&cru SRST_P_MIPICSIPHY>;
+		reset-names = "srst_p_csiphy";
+		rockchip,grf = <&grf>;
+		status = "disabled";
+	};
+
+	dmac: dma-controller@ff420000 {
+		compatible = "arm,pl330", "arm,primecell";
+		reg = <0xff420000 0x4000>;
+		interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+		#dma-cells = <1>;
+		clocks = <&cru ACLK_DMAC>;
+		clock-names = "apb_pclk";
+		arm,pl330-periph-burst;
+	};
+
+	crypto: crypto@ff440000 {
+		compatible = "rockchip,crypto-v3";
+		reg = <0xff440000 0x2000>;
+		interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_CRYPTO>, <&cru HCLK_CRYPTO>,
+			 <&cru CLK_CORE_CRYPTO>, <&cru CLK_PKA_CRYPTO>;
+		clock-names = "aclk", "hclk", "sclk", "pka";
+		assigned-clocks = <&cru CLK_CORE_CRYPTO>, <&cru CLK_PKA_CRYPTO>;
+		assigned-clock-rates = <200000000>, <200000000>;
+		resets = <&cru SRST_CORE_CRYPTO>;
+		reset-names = "crypto-rst";
+		status = "disabled";
+	};
+
+	rng: rng@ff448000 {
+		compatible = "rockchip,trngv1";
+		reg = <0xff448000 0x200>;
+		interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_TRNG_NS>;
+		clock-names = "hclk_trng";
+		resets = <&cru SRST_H_TRNG_NS>;
+		reset-names = "reset";
+		status = "disabled";
+	};
+
+	i2c2: i2c@ff450000 {
+		compatible = "rockchip,rv1106-i2c", "rockchip,rk3399-i2c";
+		reg = <0xff450000 0x1000>;
+		interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_I2C2>, <&cru PCLK_I2C2>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c2m0_xfer>;
+		status = "disabled";
+	};
+
+	i2c3: i2c@ff460000 {
+		compatible = "rockchip,rv1106-i2c", "rockchip,rk3399-i2c";
+		reg = <0xff460000 0x1000>;
+		interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_I2C3>, <&cru PCLK_I2C3>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c3m0_xfer>;
+		status = "disabled";
+	};
+
+	i2c4: i2c@ff470000 {
+		compatible = "rockchip,rv1106-i2c", "rockchip,rk3399-i2c";
+		reg = <0xff470000 0x1000>;
+		interrupts = <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_I2C4>, <&cru PCLK_I2C4>;
+		clock-names = "i2c", "pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c4m0_xfer>;
+		status = "disabled";
+	};
+
+	acodec: acodec@ff480000 {
+		compatible = "rockchip,rv1106-codec";
+		reg = <0xff480000 0x1000>;
+		rockchip,grf = <&grf>;
+		clocks = <&cru PCLK_ACODEC>,
+			 <&cru MCLK_ACODEC_TX>,
+			 <&cru MCLK_I2S0_8CH_TX>;
+		clock-names = "pclk_acodec", "mclk_acodec", "mclk_cpu";
+		resets = <&cru SRST_P_ACODEC>;
+		reset-names = "acodec-reset";
+		acodec,micbias;
+		init-mic-gain = <0x22>; /* Left:20dB Right:20dB */
+		status = "disabled";
+	};
+
+	pwm8: pwm@ff490000 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff490000 0x10>;
+		interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm8m0_pins>;
+		clocks = <&cru CLK_PWM2_PERI>, <&cru PCLK_PWM2_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm9: pwm@ff490010 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff490010 0x10>;
+		interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm9m0_pins>;
+		clocks = <&cru CLK_PWM2_PERI>, <&cru PCLK_PWM2_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm10: pwm@ff490020 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff490020 0x10>;
+		interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm10m0_pins>;
+		clocks = <&cru CLK_PWM2_PERI>, <&cru PCLK_PWM2_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	pwm11: pwm@ff490030 {
+		compatible = "rockchip,rv1106-pwm", "rockchip,rk3328-pwm";
+		reg = <0xff490030 0x10>;
+		interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+		#pwm-cells = <3>;
+		pinctrl-names = "active";
+		pinctrl-0 = <&pwm11m0_pins>;
+		clocks = <&cru CLK_PWM2_PERI>, <&cru PCLK_PWM2_PERI>;
+		clock-names = "pwm", "pclk";
+		status = "disabled";
+	};
+
+	uart0: serial@ff4a0000 {
+		compatible = "rockchip,rv1106-uart", "snps,dw-apb-uart";
+		reg = <0xff4a0000 0x100>;
+		interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac 7>, <&dmac 6>;
+		clock-frequency = <24000000>;
+		clocks = <&cru SCLK_UART0>, <&cru PCLK_UART0>;
+		clock-names = "baudclk", "apb_pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart0m0_xfer>;
+		status = "disabled";
+	};
+
+	uart1: serial@ff4b0000 {
+		compatible = "rockchip,rv1106-uart", "snps,dw-apb-uart";
+		reg = <0xff4b0000 0x100>;
+		interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac 9>, <&dmac 8>;
+		clock-frequency = <24000000>;
+		clocks = <&cru SCLK_UART1>, <&cru PCLK_UART1>;
+		clock-names = "baudclk", "apb_pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart1m0_xfer &uart1m0_ctsn &uart1m0_rtsn>;
+		status = "disabled";
+	};
+
+	uart2: serial@ff4c0000 {
+		compatible = "rockchip,rv1106-uart", "snps,dw-apb-uart";
+		reg = <0xff4c0000 0x100>;
+		interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac 11>, <&dmac 10>;
+		clock-frequency = <24000000>;
+		clocks = <&cru SCLK_UART2>, <&cru PCLK_UART2>;
+		clock-names = "baudclk", "apb_pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m1_xfer>;
+		status = "disabled";
+	};
+
+	uart3: serial@ff4d0000 {
+		compatible = "rockchip,rv1106-uart", "snps,dw-apb-uart";
+		reg = <0xff4d0000 0x100>;
+		interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac 13>, <&dmac 12>;
+		clock-frequency = <24000000>;
+		clocks = <&cru SCLK_UART3>, <&cru PCLK_UART3>;
+		clock-names = "baudclk", "apb_pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart3m0_xfer>;
+		status = "disabled";
+	};
+
+	uart4: serial@ff4e0000 {
+		compatible = "rockchip,rv1106-uart", "snps,dw-apb-uart";
+		reg = <0xff4e0000 0x100>;
+		interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac 15>, <&dmac 14>;
+		clock-frequency = <24000000>;
+		clocks = <&cru SCLK_UART4>, <&cru PCLK_UART4>;
+		clock-names = "baudclk", "apb_pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart4m0_xfer>;
+		status = "disabled";
+	};
+
+	uart5: serial@ff4f0000 {
+		compatible = "rockchip,rv1106-uart", "snps,dw-apb-uart";
+		reg = <0xff4f0000 0x100>;
+		interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		dmas = <&dmac 17>, <&dmac 16>;
+		clock-frequency = <24000000>;
+		clocks = <&cru SCLK_UART5>, <&cru PCLK_UART5>;
+		clock-names = "baudclk", "apb_pclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart5m0_xfer &uart5m0_ctsn &uart5m0_rtsn>;
+		status = "disabled";
+	};
+
+	spi0: spi@ff500000 {
+		compatible = "rockchip,rv1106-spi", "rockchip,rk3066-spi";
+		reg = <0xff500000 0x1000>;
+		interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI0>, <&cru PCLK_SPI0>, <&cru SCLK_IN_SPI0>;
+		clock-names = "spiclk", "apb_pclk", "sclk_in";
+		dmas = <&dmac 1>, <&dmac 0>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi0m0_cs0 &spi0m0_cs1 &spi0m0_pins>;
+		status = "disabled";
+	};
+
+	spi1: spi@ff510000 {
+		compatible = "rockchip,rv1106-spi", "rockchip,rk3066-spi";
+		reg = <0xff510000 0x1000>;
+		interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI1>, <&cru PCLK_SPI1>;
+		clock-names = "spiclk", "apb_pclk";
+		assigned-clocks = <&cru CLK_SPI1>;
+		assigned-clock-rates = <200000000>;
+		dmas = <&dmac 3>, <&dmac 2>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi1m0_cs0 &spi1m0_cs1 &spi1m0_pins>;
+		status = "disabled";
+	};
+
+	hw_decompress: decompress@ff520000 {
+		compatible = "rockchip,hw-decompress";
+		reg = <0xff520000 0x1000>;
+		interrupts = <GIC_SPI 112 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_DECOM>, <&cru DCLK_DECOM>, <&cru PCLK_DECOM>;
+		clock-names = "aclk", "dclk", "pclk";
+		resets = <&cru SRST_D_DECOM>;
+		reset-names = "dresetn";
+		status = "disabled";
+	};
+
+	ioc: syscon@ff538000 {
+		compatible = "rockchip,rv1106-ioc", "syscon";
+		reg = <0xff538000 0x40000>;
+	};
+
+	wdt: watchdog@ff5a0000 {
+		compatible = "rockchip,rv1106-wdt", "snps,dw-wdt";
+		reg = <0xff5a0000 0x100>;
+		clocks = <&cru TCLK_WDT_NS>, <&cru PCLK_WDT_NS>;
+		clock-names = "tclk", "pclk";
+		interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+
+	mailbox: mailbox@ff5c0000 {
+		compatible = "rockchip,rv1106-mailbox",
+			     "rockchip,rk3368-mailbox";
+		reg = <0xff5c0000 0x200>;
+		interrupts = <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru PCLK_MAILBOX>;
+		clock-names = "pclk_mailbox";
+		#mbox-cells = <1>;
+		status = "disabled";
+	};
+
+	npu: npu@ff660000 {
+		compatible = "rockchip,rv1106-rknpu";
+		reg = <0xff660000 0x10000>;
+		interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_RKNN>, <&cru HCLK_RKNN>;
+		clock-names = "aclk", "hclk";
+		assigned-clocks = <&cru ACLK_RKNN>;
+		assigned-clock-rates = <420000000>;
+		resets = <&cru SRST_A_RKNN>, <&cru SRST_H_RKNN>;
+		reset-names = "srst_a", "srst_h";
+		status = "disabled";
+	};
+
+	system_sram: sram@ff6c0000 {
+		compatible = "mmio-sram";
+		reg = <0xff6c0000 0x40000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0 0xff6c0000 0x40000>;
+		rkisp_sram: rkisp-sram@0 {
+			reg = <0x0 0x3e000>;
+		};
+		hpmcu_sram: hpmcu-sram@3e000 {
+			reg = <0x3e000 0x2000>;
+		};
+	};
+
+	rga2: rga@ff980000 {
+		compatible = "rockchip,rga2_core0";
+		reg = <0xff980000 0x1000>;
+		interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_RGA2E>, <&cru HCLK_RGA2E>, <&cru CLK_CORE_RGA2E>;
+		clock-names = "aclk_rga2", "hclk_rga2", "clk_rga2";
+		status = "disabled";
+	};
+
+	vop: vop@ff990000 {
+		compatible = "rockchip,rv1106-vop";
+		reg = <0xff990000 0x200>;
+		reg-names = "regs";
+		rockchip,grf = <&grf>;
+		interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_VOP>, <&cru DCLK_VOP>, <&cru HCLK_VOP>;
+		clock-names = "aclk_vop", "dclk_vop", "hclk_vop";
+		status = "disabled";
+
+		vop_out: port {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			vop_out_rgb: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&rgb_in_vop>;
+			};
+		};
+	};
+
+	sdio: mmc@ff9a0000 {
+		compatible = "rockchip,rv1106-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0xff9a0000 0x4000>;
+		interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_SDIO>, <&cru CCLK_SRC_SDIO>,
+			 <&grf_cru SCLK_SDIO_DRV>, <&grf_cru SCLK_SDIO_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <200000000>;
+		status = "disabled";
+	};
+
+	rkisp: rkisp@ffa00000 {
+		compatible = "rockchip,rv1106-rkisp";
+		reg = <0xffa00000 0x7f00>;
+		interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "isp_irq", "mi_irq", "mipi_irq";
+		clocks = <&cru ACLK_ISP3P2>, <&cru HCLK_ISP3P2>,
+			 <&cru CLK_CORE_ISP3P2>, <&cru ISP0CLK_VICAP>;
+		clock-names = "aclk_isp", "hclk_isp",
+			      "clk_isp_core", "clk_isp_core_vicap";
+		rockchip,sram = <&rkisp_sram>;
+		status = "disabled";
+	};
+
+	rkcif: rkcif@ffa10000 {
+		compatible = "rockchip,rv1106-cif";
+		reg = <0xffa10000 0x10000>;
+		reg-names = "cif_regs";
+		interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "cif-intr";
+		clocks = <&cru ACLK_VICAP>, <&cru HCLK_VICAP>,
+			 <&cru DCLK_VICAP>, <&cru PCLK_VICAP>,
+			 <&cru I0CLK_VICAP>, <&cru I1CLK_VICAP>,
+			 <&cru RX0PCLK_VICAP>, <&cru RX1PCLK_VICAP>,
+			 <&cru ISP0CLK_VICAP>, <&cru SCLK_VICAP_M0>,
+			 <&cru SCLK_VICAP_M1>, <&cru PCLK_VICAP_VEPU>;
+		clock-names = "aclk_cif","hclk_cif",
+			      "dclk_cif", "pclk_cif",
+			      "i0clk_cif", "i1clk_cif",
+			      "rx0clk_cif", "rx1clk_cif",
+			      "isp0clk_cif", "sclk_m0_cif",
+			      "sclk_m1_cif", "pclk_vepu_cif";
+		resets = <&cru SRST_A_VICAP>, <&cru SRST_H_VICAP>,
+			 <&cru SRST_D_VICAP>, <&cru SRST_P_VICAP>,
+			 <&cru SRST_VICAP_I0>, <&cru SRST_VICAP_I1>,
+			 <&cru SRST_VICAP_RX0>, <&cru SRST_VICAP_RX1>,
+			 <&cru SRST_VICAP_ISP0>, <&cru SRST_P_VICAP_VEPU>;
+		reset-names = "rst_cif_a","rst_cif_h",
+			      "rst_cif_d", "rst_cif_p",
+			      "rst_cif_i0", "rst_cif_i1",
+			      "rst_cif_rx0", "rst_cif_rx1",
+			      "rst_cif_isp0", "rst_cif_pclk_vepu";
+		rockchip,grf = <&grf>;
+		status = "disabled";
+	};
+
+	mipi0_csi2_hw: mipi-csi2-hw@ffa20000 {
+		compatible = "rockchip,rv1106-mipi-csi2-hw";
+		reg = <0xffa20000 0x10000>;
+		reg-names = "csihost_regs";
+		interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "csi-intr1", "csi-intr2";
+		clocks = <&cru PCLK_CSIHOST0>, <&cru CLK_RXBYTECLKHS_0>;
+		clock-names = "pclk_csi2host", "clk_rxbyte_hs";
+		resets = <&cru SRST_P_CSIHOST0>;
+		reset-names = "srst_csihost_p";
+		status = "okay";
+	};
+
+	mipi1_csi2_hw: mipi-csi2-hw@ffa30000 {
+		compatible = "rockchip,rv1106-mipi-csi2-hw";
+		reg = <0xffa30000 0x10000>;
+		reg-names = "csihost_regs";
+		interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "csi-intr1", "csi-intr2";
+		clocks = <&cru PCLK_CSIHOST1>, <&cru CLK_RXBYTECLKHS_1>;
+		clock-names = "pclk_csi2host", "clk_rxbyte_hs";
+		resets = <&cru SRST_P_CSIHOST1>;
+		reset-names = "srst_csihost_p";
+		status = "okay";
+	};
+
+	rkvenc: rkvenc@ffa50000 {
+		compatible = "rockchip,rkv-encoder-rv1106";
+		reg = <0xffa50000 0x6000>;
+		interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_rkvenc";
+		clocks = <&cru ACLK_VEPU>, <&cru HCLK_VEPU>, <&cru CLK_CORE_VEPU>;
+		clock-names = "aclk_vcodec", "hclk_vcodec", "clk_core";
+		rockchip,normal-rates = <300000000>, <0>, <410000000>;
+		assigned-clocks = <&cru ACLK_VEPU>, <&cru CLK_CORE_VEPU>;
+		assigned-clock-rates = <300000000>, <400000000>;
+		resets = <&cru SRST_A_VEPU>, <&cru SRST_H_VEPU>, <&cru SRST_CORE_VEPU>;
+		reset-names = "video_a", "video_h", "video_core";
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <0>;
+		dvbm = <&rkdvbm>;
+		status = "disabled";
+	};
+
+	rkvenc_pp: rkvenc-pp@ffa60000 {
+		compatible = "rockchip,rkvenc-pp-rv1106";
+		reg = <0xffa60000 0x900>;
+		interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_rkvenc_pp";
+		clocks = <&cru ACLK_VEPU_PP>, <&cru HCLK_VEPU_PP>;
+		clock-names = "aclk_vepu_pp", "hclk_vepu_pp";
+		assigned-clocks = <&cru ACLK_VEPU_PP>, <&cru HCLK_VEPU_PP>;
+		resets = <&cru SRST_A_VEPU_PP>, <&cru SRST_H_VEPU_PP>;
+		rockchip,srv = <&mpp_srv>;
+		rockchip,taskqueue-node = <1>;
+		status = "disabled";
+	};
+
+	rkdvbm: rkdvbm@ffa70000 {
+		compatible = "rockchip,rk-dvbm";
+		reg = <0xffa70000 0x90>;
+		interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_rkdvbm";
+		clocks = <&cru CLK_CORE_VEPU_DVBM>;
+		clock-names = "clk_core";
+		assigned-clocks = <&cru CLK_CORE_VEPU_DVBM>;
+		assigned-clock-rates = <200000000>;
+		resets = <&cru SRST_CORE_VEPU_DVBM>;
+		reset-names = "dvbm_rst";
+		status = "disabled";
+	};
+
+	gmac: ethernet@ffa80000 {
+		compatible = "rockchip,rv1106-gmac", "snps,dwmac-4.20a";
+		reg = <0xffa80000 0x10000>;
+		interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq", "eth_wake_irq";
+		rockchip,grf = <&grf>;
+		clocks = <&cru CLK_GMAC0_TX_50M_O>, <&cru CLK_GMAC0_REF_50M>,
+			 <&cru ACLK_MAC>, <&cru PCLK_MAC>;
+		clock-names = "stmmaceth", "clk_mac_ref",
+			      "aclk_mac", "pclk_mac";
+		resets = <&cru SRST_A_MAC>;
+		reset-names = "stmmaceth";
+
+		snps,mixed-burst;
+		snps,tso;
+
+		tx-dma-size = <256>;
+		rx-dma-size = <128>;
+
+		snps,axi-config = <&stmmac_axi_setup>;
+		snps,mtl-rx-config = <&mtl_rx_setup>;
+		snps,mtl-tx-config = <&mtl_tx_setup>;
+
+		phy-mode = "rmii";
+		clock_in_out = "input";
+		phy-handle = <&rmii_phy>;
+
+		/* FLOW_OFF: 0, FLOW_RX: 1, FLOW_TX: 2, FLOW_AUTO: 3 */
+		snps,flow-ctrl = <0>;
+
+		nvmem-cells = <&macphy_bgs>;
+		nvmem-cell-names = "bgs";
+		status = "disabled";
+
+		mdio: mdio {
+			compatible = "snps,dwmac-mdio";
+			#address-cells = <0x1>;
+			#size-cells = <0x0>;
+			rmii_phy: ethernet-phy@2 {
+				compatible = "ethernet-phy-id0044.1400", "ethernet-phy-ieee802.3-c22";
+				reg = <2>;
+				clocks = <&cru CLK_MACPHY>;
+				resets = <&cru SRST_MACPHY>;
+				phy-is-integrated;
+				nvmem-cells = <&macphy_txlevel>;
+				nvmem-cell-names = "txlevel";
+				bgs,increment = <2>;
+				rockchip,thermal-zone = "soc-thermal";
+			};
+		};
+
+		stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <4>;
+			snps,rd_osr_lmt = <8>;
+			snps,blen = <0 0 0 0 16 8 4>;
+		};
+
+		mtl_rx_setup: rx-queues-config {
+			snps,rx-queues-to-use = <1>;
+			queue0 {
+				status = "okay";
+			};
+		};
+
+		mtl_tx_setup: tx-queues-config {
+			snps,tx-queues-to-use = <1>;
+			queue0 {
+				status = "okay";
+			};
+		};
+	};
+
+	emmc: mmc@ffa90000 {
+		compatible = "rockchip,rv1106-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0xffa90000 0x4000>;
+		interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_EMMC>, <&cru CCLK_SRC_EMMC>,
+			 <&grf_cru SCLK_EMMC_DRV>, <&grf_cru SCLK_EMMC_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <200000000>;
+		rockchip,use-v2-tuning;
+		status = "disabled";
+	};
+
+	sdmmc: mmc@ffaa0000 {
+		compatible = "rockchip,rv1106-dw-mshc", "rockchip,rk3288-dw-mshc";
+		reg = <0xffaa0000 0x4000>;
+		interrupts = <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_SDMMC>, <&cru CCLK_SRC_SDMMC>,
+			 <&grf_cru SCLK_SDMMC_DRV>, <&grf_cru SCLK_SDMMC_SAMPLE>;
+		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		fifo-depth = <0x100>;
+		max-frequency = <200000000>;
+		status = "disabled";
+	};
+
+	sfc: spi@ffac0000 {
+		compatible = "rockchip,sfc";
+		reg = <0xffac0000 0x4000>;
+		interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru SCLK_SFC>, <&cru HCLK_SFC>;
+		clock-names = "clk_sfc", "hclk_sfc";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "disabled";
+	};
+
+	rve: rve@ffad0000 {
+		compatible = "rockchip,rve";
+		reg = <0xffad0000 0x1000>;
+		interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru ACLK_IVE>, <&cru HCLK_IVE>;
+		clock-names = "aclk_rve", "hclk_rve";
+		status = "disabled";
+	};
+
+	i2s0_8ch: i2s@ffae0000 {
+		compatible = "rockchip,rv1106-i2s-tdm";
+		reg = <0xffae0000 0x1000>;
+		interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru MCLK_I2S0_8CH_TX>, <&cru MCLK_I2S0_8CH_RX>, <&cru HCLK_I2S0>;
+		clock-names = "mclk_tx", "mclk_rx", "hclk";
+		dmas = <&dmac 22>, <&dmac 21>;
+		dma-names = "tx", "rx";
+		resets = <&cru SRST_M_I2S0_8CH_TX>, <&cru SRST_M_I2S0_8CH_RX>;
+		reset-names = "tx-m", "rx-m";
+		rockchip,clk-trcm = <1>;
+		#sound-dai-cells = <0>;
+		status = "disabled";
+	};
+
+	usbdrd: usbdrd {
+		compatible = "rockchip,rv1106-dwc3", "rockchip,rk3399-dwc3";
+		clocks = <&cru CLK_REF_USBOTG>, <&cru CLK_UTMI_USBOTG>,
+			 <&cru ACLK_USBOTG>;
+		clock-names = "ref", "utmi", "bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		status = "disabled";
+
+		usbdrd_dwc3: usb@ffb00000 {
+			compatible = "snps,dwc3";
+			reg = <0xffb00000 0x100000>;
+			interrupts = <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>;
+			resets = <&cru SRST_A_USBOTG>;
+			reset-names = "usb3-otg";
+			dr_mode = "otg";
+			maximum-speed = "high-speed";
+			phys = <&u2phy_otg>;
+			phy-names = "usb2-phy";
+			phy_type = "utmi_wide";
+			snps,dis_enblslpm_quirk;
+			snps,dis-u2-freeclk-exists-quirk;
+			snps,dis_u2_susphy_quirk;
+			snps,dis-del-phy-power-chg-quirk;
+			snps,dis-tx-ipgap-linecheck-quirk;
+			snps,usb2-gadget-lpm-disable;
+			snps,usb2-lpm-disable;
+			snps,parkmode-disable-hs-quirk;
+			status = "disabled";
+		};
+	};
+
+	pinctrl: pinctrl {
+		compatible = "rockchip,rv1106-pinctrl";
+		rockchip,grf = <&ioc>;
+		rockchip,pmu = <&pmuioc>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		gpio0: gpio@ff380000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0xff380000 0x100>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_PMU_GPIO0>, <&cru DBCLK_PMU_GPIO0>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl 0 0 32>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio1: gpio@ff530000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0xff530000 0x100>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO1>, <&cru DBCLK_GPIO1>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl 0 32 32>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio2: gpio@ff540000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0xff540000 0x100>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO2>, <&cru DBCLK_GPIO2>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl 0 64 32>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio3: gpio@ff550000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0xff550000 0x100>;
+			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO3>, <&cru DBCLK_GPIO3>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl 0 96 32>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio4: gpio@ff560000 {
+			compatible = "rockchip,gpio-bank";
+			reg = <0xff560000 0x100>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&cru PCLK_GPIO4>, <&cru DBCLK_GPIO4>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pinctrl 0 128 32>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+};
+
+#include "rv1106-pinctrl.dtsi"
diff --git a/arch/arm/configs/luckfox_rv1106_linux_defconfig b/arch/arm/configs/luckfox_rv1106_linux_defconfig
new file mode 100755
index 000000000..152559a29
--- /dev/null
+++ b/arch/arm/configs/luckfox_rv1106_linux_defconfig
@@ -0,0 +1,347 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_XZ=y
+CONFIG_DEFAULT_HOSTNAME="luckfox"
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_CGROUPS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_BUG is not set
+# CONFIG_BASE_FULL is not set
+# CONFIG_IO_URING is not set
+CONFIG_EMBEDDED=y
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_ARCH_ROCKCHIP=y
+# CONFIG_VDSO is not set
+CONFIG_VMSPLIT_3G_OPT=y
+CONFIG_THUMB2_KERNEL=y
+# CONFIG_CPU_SW_DOMAIN_PAN is not set
+CONFIG_FORCE_MAX_ZONEORDER=9
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_CMDLINE="user_debug=31"
+CONFIG_CMDLINE_EXTEND=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_ROCKCHIP_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+# CONFIG_SUSPEND is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_STACKPROTECTOR_STRONG is not set
+# CONFIG_STRICT_KERNEL_RWX is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+# CONFIG_MQ_IOSCHED_KYBER is not set
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_CMA=y
+CONFIG_CMA_INACTIVE=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_INET_TABLE_PERTURB_ORDER=8
+# CONFIG_INET_DIAG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_SIT is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_OF_PARTS is not set
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_MTD_SPI_NOR_MISC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_BLOCK=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_DTBO=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_UFSHCD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_CORE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_DWMAC_GENERIC is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_RK630_PHY=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+# CONFIG_WLAN_VENDOR_ATH is not set
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_CISCO is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_MICROCHIP is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+CONFIG_WL_ROCKCHIP=m
+CONFIG_WIFI_BUILD_MODULE=y
+# CONFIG_BCMDHD is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADC=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_EDT_FT5X06=y
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+CONFIG_SERIAL_8250_DW=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_ROCKCHIP=y
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_RK3X=y
+CONFIG_SPI=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_ROCKCHIP_SFC=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_SPI_SLAVE=y
+# CONFIG_PTP_1588_CLOCK is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_RESTART=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_ROCKCHIP_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_PWM=y
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+CONFIG_MEDIA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_TEST_SUPPORT is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_VIDEOBUF2_CMA_SG=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_ROCKCHIP_CIF=m
+CONFIG_VIDEO_ROCKCHIP_ISP=m
+CONFIG_VIDEO_RK_IRCUT=y
+CONFIG_VIDEO_MIS5001=m
+CONFIG_VIDEO_SC3336=m
+CONFIG_DRM=y
+CONFIG_DRM_EDID=y
+CONFIG_DRM_ROCKCHIP=y
+CONFIG_ROCKCHIP_VOP=y
+CONFIG_ROCKCHIP_RGB=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_SII902X=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_ROCKCHIP_MULTI_RGA=m
+CONFIG_ROCKCHIP_RGA_PROC_FS=y
+# CONFIG_ROCKCHIP_RGA_DEBUG_FS is not set
+CONFIG_ROCKCHIP_RVE=m
+CONFIG_ROCKCHIP_RVE_PROC_FS=y
+CONFIG_ROCKCHIP_DVBM=m
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_PCM_TIMER is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_ROCKCHIP=y
+CONFIG_SND_SOC_ROCKCHIP_I2S_TDM=y
+CONFIG_SND_SOC_RV1106=y
+CONFIG_SND_SIMPLE_CARD=y
+# CONFIG_HID is not set
+# CONFIG_USB_HID is not set
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_GADGETFS=y
+CONFIG_USB_MASS_STORAGE=y
+CONFIG_MMC=y
+# CONFIG_PWRSEQ_EMMC is not set
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_QUEUE_DEPTH=1
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_ROCKCHIP=y
+CONFIG_DMADEVICES=y
+CONFIG_PL330_DMA=y
+CONFIG_DMABUF_HEAPS_ROCKCHIP=y
+CONFIG_DMABUF_HEAPS_ROCKCHIP_CMA_HEAP=y
+CONFIG_DMABUF_HEAPS_ROCKCHIP_CMA_ALIGNMENT=0
+CONFIG_DMABUF_RK_HEAPS_DEBUG=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+CONFIG_STAGING=y
+CONFIG_FB_TFT=y
+CONFIG_FB_TFT_ST7735R=y
+CONFIG_FB_TFT_ST7789V=y
+CONFIG_COMMON_CLK_PROCFS=y
+# CONFIG_ARM_ARCH_TIMER_EVTSTREAM is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_CPU_RV1106=y
+CONFIG_ROCKCHIP_AMP=y
+CONFIG_ROCKCHIP_CPUINFO=y
+CONFIG_ROCKCHIP_IOMUX=y
+CONFIG_ROCKCHIP_OPP=y
+CONFIG_ROCKCHIP_PVTM=y
+CONFIG_ROCKCHIP_SYSTEM_MONITOR=y
+CONFIG_ROCKCHIP_VENDOR_STORAGE=y
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_RK_CONSOLE_THREAD=y
+CONFIG_FIQ_DEBUGGER_FIQ_GLUE=y
+CONFIG_ROCKCHIP_NPOR_POWERGOOD=y
+CONFIG_RK_CMA_PROCFS=y
+CONFIG_RK_DMABUF_PROCFS=y
+CONFIG_RK_MEMBLOCK_PROCFS=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_EXTCON=y
+CONFIG_IIO=y
+CONFIG_ROCKCHIP_SARADC=y
+CONFIG_PWM=y
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_CSI2_DPHY=m
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_MIPI_RX=y
+CONFIG_ANDROID=y
+CONFIG_ROCKCHIP_OTP=y
+CONFIG_ROCKCHIP_RKNPU=m
+# CONFIG_ROCKCHIP_RKNPU_DEBUG_FS is not set
+CONFIG_ROCKCHIP_RKNPU_PROC_FS=y
+CONFIG_ROCKCHIP_RKNPU_DMA_HEAP=y
+CONFIG_EXT4_FS=y
+CONFIG_EXPORTFS_BLOCK_OPS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_VFAT_FS=y
+CONFIG_EXFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+# CONFIG_JFFS2_RTIME is not set
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+# CONFIG_UBIFS_FS_ZSTD is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_ZLIB is not set
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_4K_DEVBLK_SIZE=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_ZSTD=y
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=0
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_FS=y
+# CONFIG_DEBUG_MISC is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/arch/arm/mach-rockchip/Kconfig b/arch/arm/mach-rockchip/Kconfig
index b7855cc66..120174611 100644
--- a/arch/arm/mach-rockchip/Kconfig
+++ b/arch/arm/mach-rockchip/Kconfig
@@ -22,3 +22,19 @@ config ARCH_ROCKCHIP
 	help
 	  Support for Rockchip's Cortex-A9 Single-to-Quad-Core-SoCs
 	  containing the RK2928, RK30xx and RK31xx series.
+
+if PM_SLEEP
+config PM_SLEEP_RK3288
+	tristate "Rockchip RK3288 pm sleep support"
+	depends on ARCH_ROCKCHIP
+	default y
+	help
+	  Build the driver for RK3288 PM Sleep Driver.
+
+config PM_SLEEP_RV1106
+	bool "Rockchip RV1106 clock controller support"
+	depends on ARCH_ROCKCHIP
+	default y
+	help
+	  Build the driver for RV1106 PM Sleep Driver.
+endif
diff --git a/arch/arm/mach-rockchip/Makefile b/arch/arm/mach-rockchip/Makefile
index 62596d5de..895e33781 100644
--- a/arch/arm/mach-rockchip/Makefile
+++ b/arch/arm/mach-rockchip/Makefile
@@ -2,5 +2,7 @@
 CFLAGS_platsmp.o := -march=armv7-a
 
 obj-$(CONFIG_ARCH_ROCKCHIP) += rockchip.o
-obj-$(CONFIG_PM_SLEEP) += pm.o sleep.o
+ifdef CONFIG_PM_SLEEP
+obj-$(CONFIG_PM_SLEEP_RK3288) += pm.o sleep.o
+endif
 obj-$(CONFIG_SMP) += headsmp.o platsmp.o
diff --git a/arch/arm/mach-rockchip/rkpm_gicv2.c b/arch/arm/mach-rockchip/rkpm_gicv2.c
new file mode 100644
index 000000000..2b115a218
--- /dev/null
+++ b/arch/arm/mach-rockchip/rkpm_gicv2.c
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
+
+#include "rkpm_helpers.h"
+#include "rkpm_gicv2.h"
+
+void rkpm_gicv2_dist_save(void __iomem *dist_base,
+			  struct plat_gicv2_dist_ctx_t *ctx)
+{
+	int i;
+	int gic_irqs;
+
+	gic_irqs = readl_relaxed(dist_base + GIC_DIST_CTR) & 0x1f;
+	gic_irqs = (gic_irqs + 1) << 5;
+	if (gic_irqs > 1020)
+		gic_irqs = 1020;
+
+	for (i = 32; i < gic_irqs; i += 4)
+		ctx->saved_spi_target[i >> 2] =
+			readl_relaxed(dist_base + GIC_DIST_TARGET + i);
+
+	for (i = 32; i < gic_irqs; i += 4)
+		ctx->saved_spi_prio[i >> 2] =
+			readl_relaxed(dist_base + GIC_DIST_PRI + i);
+
+	for (i = 32; i < gic_irqs; i += 16)
+		ctx->saved_spi_conf[i >> 4] =
+			readl_relaxed(dist_base + GIC_DIST_CONFIG +
+				     (i >> 4 << 2));
+
+	for (i = 32; i < gic_irqs; i += 32)
+		ctx->saved_spi_grp[i >> 5] =
+			readl_relaxed(dist_base + GIC_DIST_IGROUP +
+				     (i >> 5 << 2));
+
+	for (i = 32; i < gic_irqs; i += 32)
+		ctx->saved_spi_active[i >> 5] =
+			readl_relaxed(dist_base + GIC_DIST_ACTIVE_SET +
+				     (i >> 5 << 2));
+
+	for (i = 32; i < gic_irqs; i += 32)
+		ctx->saved_spi_enable[i >> 5] =
+			readl_relaxed(dist_base + GIC_DIST_ENABLE_SET +
+				     (i >> 5 << 2));
+
+	ctx->saved_gicd_ctrl = readl_relaxed(dist_base + GIC_DIST_CTRL);
+}
+
+void rkpm_gicv2_dist_restore(void __iomem *dist_base,
+			     struct plat_gicv2_dist_ctx_t *ctx)
+{
+	int i = 0;
+	int gic_irqs;
+
+	gic_irqs = readl_relaxed(dist_base + GIC_DIST_CTR) & 0x1f;
+	gic_irqs = (gic_irqs + 1) << 5;
+	if (gic_irqs > 1020)
+		gic_irqs = 1020;
+
+	writel_relaxed(0, dist_base + GIC_DIST_CTRL);
+	dsb(sy);
+
+	for (i = 32; i < gic_irqs; i += 4)
+		writel_relaxed(ctx->saved_spi_target[i >> 2],
+			       dist_base + GIC_DIST_TARGET + i);
+
+	for (i = 32; i < gic_irqs; i += 4)
+		writel_relaxed(ctx->saved_spi_prio[i >> 2],
+			       dist_base + GIC_DIST_PRI + i);
+
+	for (i = 32; i < gic_irqs; i += 16)
+		writel_relaxed(ctx->saved_spi_conf[i >> 4],
+			       dist_base + GIC_DIST_CONFIG + (i >> 4 << 2));
+
+	for (i = 32; i < gic_irqs; i += 32)
+		writel_relaxed(ctx->saved_spi_grp[i >> 5],
+			       dist_base + GIC_DIST_IGROUP + (i >> 5 << 2));
+
+	for (i = 32; i < gic_irqs; i += 32) {
+		writel_relaxed(~0U, dist_base + GIC_DIST_ACTIVE_CLEAR + (i >> 5 << 2));
+		dsb(sy);
+		writel_relaxed(ctx->saved_spi_active[i >> 5],
+			       dist_base + GIC_DIST_ACTIVE_SET + (i >> 5 << 2));
+	}
+
+	for (i = 32; i < gic_irqs; i += 32) {
+		writel_relaxed(~0U, dist_base + GIC_DIST_ENABLE_CLEAR + (i >> 5 << 2));
+		dsb(sy);
+		writel_relaxed(ctx->saved_spi_enable[i >> 5],
+			       dist_base + GIC_DIST_ENABLE_SET + (i >> 5 << 2));
+	}
+
+	dsb(sy);
+
+	writel_relaxed(ctx->saved_gicd_ctrl, dist_base + GIC_DIST_CTRL);
+	dsb(sy);
+}
+
+void rkpm_gicv2_cpu_save(void __iomem *dist_base,
+			 void __iomem *cpu_base,
+			 struct plat_gicv2_cpu_ctx_t *ctx)
+{
+	int i;
+
+	ctx->saved_ppi_enable =
+		readl_relaxed(dist_base + GIC_DIST_ENABLE_SET);
+
+	ctx->saved_ppi_active =
+		readl_relaxed(dist_base + GIC_DIST_ACTIVE_SET);
+
+	for (i = 0; i < DIV_ROUND_UP(32, 16); i++)
+		ctx->saved_ppi_conf[i] =
+			readl_relaxed(dist_base + GIC_DIST_CONFIG + i * 4);
+
+	for (i = 0; i < DIV_ROUND_UP(32, 4); i++)
+		ctx->saved_ppi_prio[i] =
+			readl_relaxed(dist_base + GIC_DIST_PRI + i * 4);
+
+	ctx->saved_ppi_grp =
+			readl_relaxed(dist_base + GIC_DIST_IGROUP);
+
+	ctx->saved_gicc_pmr =
+			readl_relaxed(cpu_base + GIC_CPU_PRIMASK);
+	ctx->saved_gicc_ctrl =
+			readl_relaxed(cpu_base + GIC_CPU_CTRL);
+}
+
+void rkpm_gicv2_cpu_restore(void __iomem *dist_base,
+			    void __iomem *cpu_base,
+			    struct plat_gicv2_cpu_ctx_t *ctx)
+{
+	int i;
+
+	writel_relaxed(0, cpu_base + GIC_CPU_CTRL);
+	dsb(sy);
+
+	writel_relaxed(~0U, dist_base + GIC_DIST_ENABLE_CLEAR);
+	dsb(sy);
+	writel_relaxed(ctx->saved_ppi_enable, dist_base + GIC_DIST_ENABLE_SET);
+
+	writel_relaxed(~0U, dist_base + GIC_DIST_ACTIVE_CLEAR);
+	dsb(sy);
+	writel_relaxed(ctx->saved_ppi_active, dist_base + GIC_DIST_ACTIVE_SET);
+
+	for (i = 0; i < DIV_ROUND_UP(32, 16); i++)
+		writel_relaxed(ctx->saved_ppi_conf[i], dist_base + GIC_DIST_CONFIG + i * 4);
+
+	for (i = 0; i < DIV_ROUND_UP(32, 4); i++)
+		writel_relaxed(ctx->saved_ppi_prio[i], dist_base + GIC_DIST_PRI + i * 4);
+
+	writel_relaxed(ctx->saved_ppi_grp, dist_base + GIC_DIST_IGROUP);
+	writel_relaxed(ctx->saved_gicc_pmr, cpu_base + GIC_CPU_PRIMASK);
+	dsb(sy);
+
+	writel_relaxed(ctx->saved_gicc_ctrl, cpu_base + GIC_CPU_CTRL);
+	dsb(sy);
+}
diff --git a/arch/arm/mach-rockchip/rkpm_gicv2.h b/arch/arm/mach-rockchip/rkpm_gicv2.h
new file mode 100644
index 000000000..4d5311383
--- /dev/null
+++ b/arch/arm/mach-rockchip/rkpm_gicv2.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef RKPM_GICV2_H
+#define RKPM_GICV2_H
+
+struct plat_gicv2_dist_ctx_t {
+	u32 saved_spi_target[DIV_ROUND_UP(1020, 4)];
+	u32 saved_spi_prio[DIV_ROUND_UP(1020, 4)];
+	u32 saved_spi_conf[DIV_ROUND_UP(1020, 16)];
+	u32 saved_spi_grp[DIV_ROUND_UP(1020, 32)];
+	u32 saved_spi_active[DIV_ROUND_UP(1020, 32)];
+	u32 saved_spi_enable[DIV_ROUND_UP(1020, 32)];
+	u32 saved_gicd_ctrl;
+};
+
+struct plat_gicv2_cpu_ctx_t {
+	u32 saved_ppi_enable;
+	u32 saved_ppi_active;
+	u32 saved_ppi_conf[DIV_ROUND_UP(32, 16)];
+	u32 saved_ppi_prio[DIV_ROUND_UP(32, 4)];
+	u32 saved_ppi_grp;
+	u32 saved_gicc_ctrl;
+	u32 saved_gicc_pmr;
+};
+
+void rkpm_gicv2_dist_save(void __iomem *dist_base,
+			  struct plat_gicv2_dist_ctx_t *ctx);
+void rkpm_gicv2_dist_restore(void __iomem *dist_base,
+			     struct plat_gicv2_dist_ctx_t *ctx);
+void rkpm_gicv2_cpu_save(void __iomem *dist_base,
+			 void __iomem *cpu_base,
+			 struct plat_gicv2_cpu_ctx_t *ctx);
+void rkpm_gicv2_cpu_restore(void __iomem *dist_base,
+			    void __iomem *cpu_base,
+			    struct plat_gicv2_cpu_ctx_t *ctx);
+#endif
diff --git a/arch/arm/mach-rockchip/rkpm_helpers.c b/arch/arm/mach-rockchip/rkpm_helpers.c
new file mode 100644
index 000000000..d99f5d393
--- /dev/null
+++ b/arch/arm/mach-rockchip/rkpm_helpers.c
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#include <asm/arch_timer.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "rkpm_helpers.h"
+
+/* REG region */
+#define RGN_LEN(_rgn)		(((_rgn)->end - (_rgn)->start) / (_rgn)->stride + 1)
+
+static u32 *region_mem;
+static u32 region_mem_size;
+static int region_mem_idx;
+
+static int alloc_region_mem(u32 *buf, int max_len,
+			    struct reg_region *rgns, u32 rgn_num)
+{
+	int i;
+	int total_len = 0, len = 0;
+	struct reg_region *r = rgns;
+
+	if (!buf || !rgns) {
+		pr_err("%s invalid parameter\n", __func__);
+		return 0;
+	}
+
+	for (i = 0; i < rgn_num; i++, r++) {
+		if (total_len < max_len)
+			r->buf = &buf[total_len];
+
+		len = RGN_LEN(r);
+		total_len += len;
+	}
+
+	if (len >= max_len) {
+		pr_err("%s The buffer remain length:%d is too small for region:0x%x, at least %d\n",
+		       __func__, max_len, rgns[0].start, total_len);
+		return -ENOMEM;
+	}
+
+	return total_len;
+}
+
+/**
+ * Alloc memory to reg_region->buf from region_mem.
+ * @rgns - struct reg_region array.
+ * @rgn_num - struct reg_region array length.
+ */
+void rkpm_alloc_region_mem(struct reg_region *rgns, u32 rgn_num)
+{
+	int max_len = 0, len;
+
+	max_len = region_mem_size / sizeof(u32) -
+		  region_mem_idx;
+
+	len = alloc_region_mem(region_mem + region_mem_idx, max_len,
+			       rgns, rgn_num);
+
+	region_mem_idx += len;
+}
+
+void rkpm_region_mem_init(u32 size)
+{
+	if (!size) {
+		pr_err("%s invalid param\n", __func__);
+		return;
+	}
+
+	region_mem = kmalloc(size, GFP_KERNEL);
+	if (!region_mem) {
+		pr_err("%s malloc region memory (0x%x) err\n", __func__, size);
+		return;
+	}
+
+	region_mem_size = size;
+}
+
+/**
+ * Save (reg_region->start ~ reg_region->end) to reg_region->buf.
+ * @rgns - struct reg_region array.
+ * @rgn_num - struct reg_region array length.
+ */
+void rkpm_reg_rgn_save(struct reg_region *rgns, u32 rgn_num)
+{
+	struct reg_region *r;
+	u8 *addr;
+	u8 *start, *end;
+	int i, j;
+
+	for (i = 0; i < rgn_num; i++) {
+		r = &rgns[i];
+		start = (char *)(*r->base) + r->start;
+		end = (char *)(*r->base) + r->end;
+		for (j = 0, addr = start; addr <= end; addr += r->stride, j++)
+			r->buf[j] = readl_relaxed(addr);
+	}
+}
+
+/**
+ * Restore reg_region->buf to (reg_region->start ~ reg_region->end).
+ * @rgns - struct reg_region array.
+ * @rgn_num - struct reg_region array length.
+ */
+void rkpm_reg_rgn_restore(struct reg_region *rgns, u32 rgn_num)
+{
+	struct reg_region *r;
+	u8 *addr;
+	u8 *start, *end;
+	int i, j;
+
+	for (i = 0; i < rgn_num; i++) {
+		r = &rgns[i];
+		start = (char *)(*r->base) + r->start;
+		end = (char *)(*r->base) + r->end;
+		for (j = 0, addr = start; addr <= end; addr += r->stride, j++)
+			writel_relaxed(r->buf[j] | r->wmsk, addr);
+	}
+}
+
+void rkpm_reg_rgn_restore_reverse(struct reg_region *rgns, u32 rgn_num)
+{
+	struct reg_region *r;
+	u8 *addr;
+	u8 *start, *end;
+	int i, j;
+
+	for (i = rgn_num - 1; i >= 0; i--) {
+		r = &rgns[i];
+		start = (char *)(*r->base) + r->start;
+		end = (char *)(*r->base) + r->end;
+		j = RGN_LEN(r) - 1;
+		for (addr = end; addr >= start; addr -= r->stride, j--)
+			writel_relaxed(r->buf[j] | r->wmsk, addr);
+	}
+}
+
+/**
+ * Dump reg regions
+ * @rgns - struct reg_region array.
+ * @rgn_num - struct reg_region array length.
+ */
+void rkpm_dump_reg_rgns(struct reg_region *rgns, u32 rgn_num)
+{
+	struct reg_region *r;
+	int i;
+
+	for (i = 0; i < rgn_num; i++) {
+		r = &rgns[i];
+		rkpm_regs_dump(*r->base, r->start, r->end, r->stride);
+	}
+}
+
+#pragma weak rkpm_printch
+void rkpm_printch(int c)
+{
+}
+
+void rkpm_printstr(const char *s)
+{
+	while (*s) {
+		rkpm_printch(*s);
+		s++;
+	}
+}
+
+void rkpm_printhex(u32 hex)
+{
+	u8 i = 8;
+	u8 c;
+
+	rkpm_printch('0');
+	rkpm_printch('x');
+	while (i--) {
+		c = (hex & 0xf0000000) >> 28;
+		rkpm_printch(c < 0xa ? c + '0' : c - 0xa + 'a');
+		hex <<= 4;
+	}
+}
+
+void rkpm_printdec(int dec)
+{
+	int i, tmp = dec;
+
+	if (dec < 0) {
+		rkpm_printch('-');
+		tmp = -dec;
+		dec = -dec;
+	}
+
+	for (i = 1; tmp / 10; tmp /= 10, i *= 10)
+		;
+
+	for (; i >= 1; i /= 10) {
+		rkpm_printch('0' + (char)(dec / i));
+		dec %= i;
+	}
+}
+
+void rkpm_regs_dump(void __iomem *base,
+		    u32 start_offset,
+		    u32 end_offset,
+		    u32 stride)
+{
+	u32 i;
+
+	for (i = start_offset; i <= end_offset; i += stride) {
+		if ((i - start_offset) % 16 == 0) {
+			rkpm_printch('\n');
+			rkpm_printhex((u32)base + i);
+			rkpm_printch(':');
+			rkpm_printch(' ');
+			rkpm_printch(' ');
+			rkpm_printch(' ');
+			rkpm_printch(' ');
+		}
+		rkpm_printhex(readl_relaxed(base + i));
+		rkpm_printch(' ');
+		rkpm_printch(' ');
+		rkpm_printch(' ');
+		rkpm_printch(' ');
+	}
+	rkpm_printch('\n');
+}
+
+void rkpm_raw_udelay(int us)
+{
+	u64 cur_cnt = __arch_counter_get_cntpct();
+	u64 del = us * 24;
+
+	while (__arch_counter_get_cntpct() - cur_cnt < del)
+		;
+}
diff --git a/arch/arm/mach-rockchip/rkpm_helpers.h b/arch/arm/mach-rockchip/rkpm_helpers.h
new file mode 100644
index 000000000..31c1b4a28
--- /dev/null
+++ b/arch/arm/mach-rockchip/rkpm_helpers.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef RKPM_HELPERS_H
+#define RKPM_HELPERS_H
+
+#define REG_MSK_SHIFT	16
+
+#ifndef BIT
+#define BIT(nr)			(1U << (nr))
+#endif
+
+#ifndef WMSK_BIT
+#define WMSK_BIT(nr)		BIT((nr) + REG_MSK_SHIFT)
+#endif
+
+/* set one bit with write mask */
+#ifndef BIT_WITH_WMSK
+#define BIT_WITH_WMSK(nr)	(BIT(nr) | WMSK_BIT(nr))
+#endif
+
+#ifndef BITS_SHIFT
+#define BITS_SHIFT(bits, shift) ((bits) << (shift))
+#endif
+
+#ifndef BITS_WMSK
+#define BITS_WMSK(msk, shift) \
+		((msk) << ((shift) + REG_MSK_SHIFT))
+#endif
+
+#ifndef BITS_WITH_WMASK
+#define BITS_WITH_WMASK(bits, msk, shift) \
+	(BITS_SHIFT(bits, shift) | BITS_SHIFT(msk, ((shift) + REG_MSK_SHIFT)))
+#endif
+
+#ifndef BIT_SET_WMSK
+#define BIT_SET_WMSK(nr)		BIT_WITH_WMSK(nr)
+#endif
+
+#ifndef BIT_CLR_WMSK
+#define BIT_CLR_WMSK(nr)		WMSK_BIT(nr)
+#endif
+
+#ifndef WITH_16BITS_WMSK
+#define WITH_16BITS_WMSK(bits)		(0xffff0000 | (bits))
+#endif
+
+#define REG_REGION(_start, _end, _stride, _base, _wmsk) \
+	.start = (_start),				\
+	.end = (_end),					\
+	.stride = (_stride),				\
+	.wmsk = (_wmsk),				\
+	.base = (_base),
+
+struct reg_region {
+	void __iomem **base;
+	u32 start;
+	u32 end;
+	u32 stride;
+	u32 wmsk;
+	u32 *buf;
+};
+
+void rkpm_alloc_region_mem(struct reg_region *rgns, u32 rgn_num);
+void rkpm_region_mem_init(u32 size);
+void rkpm_reg_rgn_save(struct reg_region *rgns, u32 rgn_num);
+void rkpm_reg_rgn_restore(struct reg_region *rgns, u32 rgn_num);
+void rkpm_reg_rgn_restore_reverse(struct reg_region *rgns, u32 rgn_num);
+void rkpm_dump_reg_rgns(struct reg_region *rgns, u32 rgn_num);
+
+void rkpm_printch(int c);
+void rkpm_printstr(const char *s);
+void rkpm_printhex(u32 hex);
+void rkpm_printdec(int dec);
+void rkpm_regs_dump(void __iomem *base,
+		    u32 start_offset,
+		    u32 end_offset,
+		    u32 stride);
+
+void rkpm_raw_udelay(int us);
+#endif
diff --git a/arch/arm/mach-rockchip/rkpm_uart.c b/arch/arm/mach-rockchip/rkpm_uart.c
new file mode 100644
index 000000000..df3b4b622
--- /dev/null
+++ b/arch/arm/mach-rockchip/rkpm_uart.c
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#include <linux/io.h>
+
+#include "rkpm_helpers.h"
+#include "rkpm_uart.h"
+
+#define UART_DEFAULT_BAUDRATE		115200
+
+void rkpm_uart_debug_init(void __iomem *base,
+			  unsigned int uart_clk,
+			  unsigned int baud_rate)
+{
+	u32 uart_dll, uart_dlh;
+	u32 div;
+
+	if (!base || !uart_clk || !baud_rate)
+		return;
+
+	div = uart_clk / baud_rate / 16;
+	uart_dll = div & 0xff;
+	uart_dlh = (div >> 8) & 0xff;
+
+	/* Reset uart */
+	writel_relaxed(XMIT_FIFO_RESET | RCVR_FIFO_RESET | UART_RESET,
+		       base + UARTSRR);
+	rkpm_raw_udelay(10);
+
+	writel_relaxed(UART_MCR_LOOP, base + UARTMCR);
+	writel_relaxed(0x83, base + UARTLCR);
+	writel_relaxed(uart_dll, base + UARTDLL);
+	writel_relaxed(uart_dlh, base + UARTDLLM);
+	writel_relaxed(0x03, base + UARTLCR);
+	writel_relaxed(0x01, base + UARTIER);
+	writel_relaxed(UARTFCR_FIFOEN, base + UARTFCR);
+	writel_relaxed(0, base + UARTMCR);
+}
+
+void rkpm_uart_debug_save(void __iomem *base,
+			  struct uart_debug_ctx *ctx)
+{
+	u32 wait_cnt = 50000;
+	u32 uart_mcr;
+
+	/* Saved the uart registers before and don't need to save again */
+	if (ctx->uart_dll || ctx->uart_dlh)
+		return;
+
+	uart_mcr = readl_relaxed(base + UARTMCR);
+	writel_relaxed(uart_mcr | UART_MCR_LOOP, base + UARTMCR);
+
+	while ((readl_relaxed(base + UARTUSR) & UARTUSR_BUSY) &&
+	       --wait_cnt)
+		rkpm_raw_udelay(10);
+
+	writel_relaxed(uart_mcr, base + UARTMCR);
+
+	/* Uart error! Unlikely to reach here */
+	if (wait_cnt == 0) {
+		rkpm_printstr("uart always busy, recover to default baudrate:");
+		rkpm_printdec(UART_DEFAULT_BAUDRATE);
+		rkpm_printstr("!!!\n");
+		rkpm_uart_debug_init(base, 24000000, UART_DEFAULT_BAUDRATE);
+	}
+
+	ctx->uart_lcr = readl_relaxed(base + UARTLCR);
+	ctx->uart_ier = readl_relaxed(base + UARTIER);
+	ctx->uart_mcr = readl_relaxed(base + UARTMCR);
+	writel_relaxed(ctx->uart_lcr | UARTLCR_DLAB, base + UARTLCR);
+	ctx->uart_dll = readl_relaxed(base + UARTDLL);
+	ctx->uart_dlh = readl_relaxed(base + UARTDLLM);
+	writel_relaxed(ctx->uart_lcr, base + UARTLCR);
+}
+
+void rkpm_uart_debug_restore(void __iomem *base,
+			     struct uart_debug_ctx *ctx)
+{
+	u32 uart_lcr, uart_mcr;
+	u32 wait_cnt = 560;
+
+	uart_mcr = readl_relaxed(base + UARTMCR);
+	writel_relaxed(uart_mcr | UART_MCR_LOOP, base + UARTMCR);
+
+	while ((readl_relaxed(base + UARTUSR) & UARTUSR_BUSY) &&
+	       --wait_cnt)
+		rkpm_raw_udelay(10);
+
+	writel_relaxed(uart_mcr, base + UARTMCR);
+
+	writel_relaxed(XMIT_FIFO_RESET | RCVR_FIFO_RESET | UART_RESET,
+		       base + UARTSRR);
+	rkpm_raw_udelay(10);
+	uart_lcr = readl_relaxed(base + UARTLCR);
+	writel_relaxed(UART_MCR_LOOP, base + UARTMCR);
+	writel_relaxed(uart_lcr | UARTLCR_DLAB, base + UARTLCR);
+	writel_relaxed(ctx->uart_dll, base + UARTDLL);
+	writel_relaxed(ctx->uart_dlh, base + UARTDLLM);
+	writel_relaxed(ctx->uart_lcr, base + UARTLCR);
+	writel_relaxed(ctx->uart_ier, base + UARTIER);
+	writel_relaxed(UARTFCR_FIFOEN, base + UARTFCR);
+	writel_relaxed(ctx->uart_mcr, base + UARTMCR);
+}
+
diff --git a/arch/arm/mach-rockchip/rkpm_uart.h b/arch/arm/mach-rockchip/rkpm_uart.h
new file mode 100644
index 000000000..69727c3f9
--- /dev/null
+++ b/arch/arm/mach-rockchip/rkpm_uart.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef RKPM_URAT_H
+#define RKPM_URAT_H
+
+#include "rkpm_helpers.h"
+
+/* UART16550 Registers */
+#define UARTTX				0x0
+#define UARTRX				0x0
+#define UARTDLL				0x0
+#define UARTIER				0x4
+#define UARTDLLM			0x4
+#define UARTIIR				0x8
+#define UARTFCR				0x8
+#define UARTLCR				0xc
+#define UARTMCR				0x10
+#define UARTLSR				0x14
+#define UARTMSR				0x18
+#define UARTSPR				0x1c
+#define UARTCSR				0x20
+
+#define UARTUSR				0x7c
+#define UARTSRR				0x88
+#define UART_MCR_LOOP			BIT(4)
+#define UART_RESET			BIT(0)
+#define RCVR_FIFO_RESET			BIT(1)
+#define XMIT_FIFO_RESET			BIT(2)
+
+/* UART_USR bits */
+#define UARTUSR_BUSY			BIT(0)
+#define UARTUSR_TFIFO_N_FULL		BIT(1)
+#define UARTUSR_TFIFO_EMPTY		BIT(2)
+#define UARTUSR_RRIFO_N_EMPTY		BIT(3)
+#define UARTUSR_RFIFO_FULL		BIT(4)
+
+#define UARTFCR_FIFOEN			(1 << 0)	/* Enable the Tx/Rx FIFO */
+
+#define UARTLCR_DLAB			(1 << 7)	/* Divisor Latch Access */
+
+struct uart_debug_ctx {
+	u32 uart_dll;
+	u32 uart_dlh;
+	u32 uart_ier;
+	u32 uart_fcr;
+	u32 uart_mcr;
+	u32 uart_lcr;
+};
+
+void rkpm_uart_debug_init(void __iomem *base,
+			  unsigned int uart_clk,
+			  unsigned int baud_rate);
+void rkpm_uart_debug_save(void __iomem *base,
+			  struct uart_debug_ctx *ctx);
+void rkpm_uart_debug_restore(void __iomem *base,
+			     struct uart_debug_ctx *ctx);
+#endif
diff --git a/arch/arm/mach-rockchip/rockchip.c b/arch/arm/mach-rockchip/rockchip.c
index 82102fbab..19547418f 100644
--- a/arch/arm/mach-rockchip/rockchip.c
+++ b/arch/arm/mach-rockchip/rockchip.c
@@ -58,6 +58,8 @@ static const char * const rockchip_board_dt_compat[] = {
 	"rockchip,rk3188",
 	"rockchip,rk3228",
 	"rockchip,rk3288",
+	"rockchip,rv1103",
+	"rockchip,rv1106",
 	"rockchip,rv1108",
 	NULL,
 };
diff --git a/arch/arm/mach-rockchip/rockchip_hptimer.c b/arch/arm/mach-rockchip/rockchip_hptimer.c
new file mode 100644
index 000000000..654712a11
--- /dev/null
+++ b/arch/arm/mach-rockchip/rockchip_hptimer.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#include <linux/io.h>
+#include <linux/math64.h>
+
+#include "rkpm_helpers.h"
+#include "rockchip_hptimer.h"
+
+/* hp timer regs */
+#define TIMER_HP_REVISION		0x0
+#define TIMER_HP_CTRL			0x4
+#define TIMER_HP_INT_EN			0x8
+#define TIMER_HP_T24_GCD		0xc
+#define TIMER_HP_T32_GCD		0x10
+#define TIMER_HP_LOAD_COUNT0		0x14
+#define TIMER_HP_LOAD_COUNT1		0x18
+#define TIMER_HP_T24_DELAT_COUNT0	0x1c
+#define TIMER_HP_T24_DELAT_COUNT1	0x20
+#define TIMER_HP_CURR_32K_VALUE0	0x24
+#define TIMER_HP_CURR_32K_VALUE1	0x28
+#define TIMER_HP_CURR_TIMER_VALUE0	0x2c
+#define TIMER_HP_CURR_TIMER_VALUE1	0x30
+#define TIMER_HP_T24_32BEGIN0		0x34
+#define TIMER_HP_T24_32BEGIN1		0x38
+#define TIMER_HP_T32_24END0		0x3c
+#define TIMER_HP_T32_24END1		0x40
+#define TIMER_HP_BEGIN_END_VALID	0x44
+#define TIMER_HP_SYNC_REQ		0x48
+#define TIMER_HP_INTR_STATUS		0x4c
+
+/* hptimer ctlr */
+enum rk_hptimer_ctlr_reg {
+	RK_HPTIMER_CTRL_EN = 0,
+	RK_HPTIMER_CTRL_MODE = 1,
+	RK_HPTIMER_CTRL_CNT_MODE = 3,
+};
+
+/* hptimer int */
+enum rk_hptimer_int_id_t {
+	RK_HPTIMER_INT_REACH = 0,
+	RK_HPTIMER_INT_ADJ_DONE = 1,
+	RK_HPTIMER_INT_SYNC = 2,
+};
+
+#define T24M_GCD		0xb71b
+#define T32K_GCD		0x40
+
+#define HPTIMER_WAIT_MAX_US	1000000
+
+static void rk_hptimer_clear_int_st(void __iomem *base, enum rk_hptimer_int_id_t id)
+{
+	writel_relaxed(BIT(id), base + TIMER_HP_INTR_STATUS);
+}
+
+static int rk_hptimer_wait_int_st(void __iomem *base,
+				  enum rk_hptimer_int_id_t id,
+				  u64 wait_us)
+{
+	while (!(readl_relaxed(base + TIMER_HP_INTR_STATUS) & BIT(id)) &&
+	       --wait_us > 0)
+		rkpm_raw_udelay(1);
+	dsb();
+
+	if (wait_us == 0) {
+		rkpm_printstr("can't wait hptimer int:");
+		rkpm_printdec(id);
+		rkpm_printch('-');
+		rkpm_printhex(readl_relaxed(base + TIMER_HP_INTR_STATUS));
+		rkpm_printch('\n');
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+static int rk_hptimer_wait_begin_end_valid(void __iomem *base, u64 wait_us)
+{
+	while ((readl_relaxed(base + TIMER_HP_BEGIN_END_VALID) & 0x3) != 0x3 &&
+	       --wait_us > 0)
+		rkpm_raw_udelay(1);
+	dsb();
+
+	if (wait_us == 0) {
+		rkpm_printstr("can't wait hptimer begin_end valid:");
+		rkpm_printhex(readl_relaxed(base + TIMER_HP_BEGIN_END_VALID));
+		rkpm_printch('\n');
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+static u64 rk_hptimer_get_soft_adjust_delt_cnt(void __iomem *base, u32 hf, u32 lf)
+{
+	u64 begin, end, delt;
+	u32 tmp;
+
+	if (rk_hptimer_wait_begin_end_valid(base, HPTIMER_WAIT_MAX_US))
+		return 0;
+
+	/* (T32_24END - T24_32BEGIN + 2) * (T24 - T32) / T32 + 2.5 * T24/T32 + 2 */
+	begin = (u64)readl_relaxed(base + TIMER_HP_T24_32BEGIN0) |
+		(u64)readl_relaxed(base + TIMER_HP_T24_32BEGIN1) << 32;
+	end = (u64)readl_relaxed(base + TIMER_HP_T32_24END0) |
+	      (u64)readl_relaxed(base + TIMER_HP_T32_24END1) << 32;
+	delt = (end - begin + 2) * (hf - lf);
+	delt = div_u64(delt, lf);
+	tmp = (2 * hf + hf / 2) / lf;
+	delt = delt + tmp + 2;
+
+	writel_relaxed(0x3, base + TIMER_HP_BEGIN_END_VALID);
+
+	return delt;
+}
+
+static void rk_hptimer_soft_adjust_req(void __iomem *base, u64 delt)
+{
+	if (delt == 0)
+		return;
+
+	writel_relaxed(delt & 0xffffffff, base + TIMER_HP_T24_DELAT_COUNT0);
+	writel_relaxed((delt >> 32) & 0xffffffff, base + TIMER_HP_T24_DELAT_COUNT1);
+	dsb();
+
+	writel_relaxed(0x1, base + TIMER_HP_SYNC_REQ);
+	dsb();
+}
+
+int rk_hptimer_is_enabled(void __iomem *base)
+{
+	return !!(readl_relaxed(base + TIMER_HP_CTRL) & BIT(RK_HPTIMER_CTRL_EN));
+}
+
+int rk_hptimer_get_mode(void __iomem *base)
+{
+	return (readl_relaxed(base + TIMER_HP_CTRL) >> RK_HPTIMER_CTRL_MODE) & 0x3;
+}
+
+u64 rk_hptimer_get_count(void __iomem *base)
+{
+	u64 cnt;
+
+	cnt = (u64)readl_relaxed(base + TIMER_HP_CURR_TIMER_VALUE0) |
+	      (u64)readl_relaxed(base + TIMER_HP_CURR_TIMER_VALUE1) << 32;
+
+	return cnt;
+}
+
+int rk_hptimer_wait_mode(void __iomem *base, enum rk_hptimer_mode_t mode)
+{
+	if (mode == RK_HPTIMER_NORM_MODE)
+		return 0;
+
+	if (mode == RK_HPTIMER_HARD_ADJUST_MODE) {
+		/* wait adjust done if hard_adjust_mode */
+		if (rk_hptimer_wait_int_st(base, RK_HPTIMER_INT_ADJ_DONE,
+					   HPTIMER_WAIT_MAX_US))
+			return -1;
+
+		rk_hptimer_clear_int_st(base, RK_HPTIMER_INT_ADJ_DONE);
+	} else if (mode == RK_HPTIMER_SOFT_ADJUST_MODE) {
+		/* wait 32k sync done */
+		if (rk_hptimer_wait_int_st(base, RK_HPTIMER_INT_SYNC,
+					   HPTIMER_WAIT_MAX_US))
+			return -1;
+
+		rk_hptimer_clear_int_st(base, RK_HPTIMER_INT_SYNC);
+	}
+
+	return 0;
+}
+
+void rk_hptimer_do_soft_adjust(void __iomem *base, u32 hf, u32 lf)
+{
+	u64 delt = rk_hptimer_get_soft_adjust_delt_cnt(base, hf, lf);
+
+	rk_hptimer_soft_adjust_req(base, delt);
+
+	rk_hptimer_wait_mode(base, RK_HPTIMER_SOFT_ADJUST_MODE);
+}
+
+void rk_hptimer_do_soft_adjust_no_wait(void __iomem *base, u32 hf, u32 lf)
+{
+	u64 delt = rk_hptimer_get_soft_adjust_delt_cnt(base, hf, lf);
+
+	rk_hptimer_soft_adjust_req(base, delt);
+}
+
+void rk_hptimer_mode_init(void __iomem *base, enum rk_hptimer_mode_t mode)
+{
+	u64 old_cnt = rk_hptimer_get_count(base);
+	u32 val;
+
+	writel_relaxed(0x0, base + TIMER_HP_CTRL);
+	writel_relaxed(0x0, base + TIMER_HP_INT_EN);
+	writel_relaxed(0x7, base + TIMER_HP_INTR_STATUS);
+	writel_relaxed(0x3, base + TIMER_HP_BEGIN_END_VALID);
+	writel_relaxed(0xffffffff, base + TIMER_HP_LOAD_COUNT0);
+	writel_relaxed(0xffffffff, base + TIMER_HP_LOAD_COUNT1);
+
+	/* config T24/T32 GCD if hard_adjust_mode */
+	if (mode == RK_HPTIMER_HARD_ADJUST_MODE) {
+		writel_relaxed(T24M_GCD, base + TIMER_HP_T24_GCD);
+		writel_relaxed(T32K_GCD, base + TIMER_HP_T32_GCD);
+	}
+	dsb();
+
+	if (mode != RK_HPTIMER_NORM_MODE) {
+		writel_relaxed(0x7, base + TIMER_HP_INT_EN);
+		writel_relaxed(mode << RK_HPTIMER_CTRL_MODE, base + TIMER_HP_CTRL);
+		dsb();
+	}
+
+	val = readl_relaxed(base + TIMER_HP_CTRL);
+	writel_relaxed(val | BIT(RK_HPTIMER_CTRL_EN), base + TIMER_HP_CTRL);
+	dsb();
+
+	/* compensate old_cnt to hptimer if soft_adjust_mode */
+	if (mode == RK_HPTIMER_SOFT_ADJUST_MODE)
+		rk_hptimer_soft_adjust_req(base, old_cnt);
+
+	if (rk_hptimer_wait_mode(base, mode))
+		pr_err("%s: can't wait hptimer mode:%d\n", __func__, mode);
+}
diff --git a/arch/arm/mach-rockchip/rockchip_hptimer.h b/arch/arm/mach-rockchip/rockchip_hptimer.h
new file mode 100644
index 000000000..eba644d80
--- /dev/null
+++ b/arch/arm/mach-rockchip/rockchip_hptimer.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ */
+
+#ifndef __ROCKCHIP_HPTIEMR_H__
+#define __ROCKCHIP_HPTIEMR_H__
+
+enum rk_hptimer_mode_t {
+	RK_HPTIMER_NORM_MODE = 0,
+	RK_HPTIMER_HARD_ADJUST_MODE = 1,
+	RK_HPTIMER_SOFT_ADJUST_MODE = 2,
+};
+
+int rk_hptimer_is_enabled(void __iomem *base);
+int rk_hptimer_get_mode(void __iomem *base);
+u64 rk_hptimer_get_count(void __iomem *base);
+int rk_hptimer_wait_mode(void __iomem *base, enum rk_hptimer_mode_t mode);
+void rk_hptimer_do_soft_adjust(void __iomem *base, u32 hf, u32 lf);
+void rk_hptimer_do_soft_adjust_no_wait(void __iomem *base, u32 hf, u32 lf);
+void rk_hptimer_mode_init(void __iomem *base, enum rk_hptimer_mode_t mode);
+#endif
diff --git a/drivers/clk/rockchip/Kconfig b/drivers/clk/rockchip/Kconfig
index 9aad86925..29a7ce738 100644
--- a/drivers/clk/rockchip/Kconfig
+++ b/drivers/clk/rockchip/Kconfig
@@ -16,12 +16,19 @@ config CLK_PX30
 	help
 	  Build the driver for PX30 Clock Driver.
 
-config CLK_RV110X
-	bool "Rockchip RV110x clock controller support"
+config CLK_RV1106
+	bool "Rockchip RV1106 clock controller support"
 	depends on ARM || COMPILE_TEST
 	default y
 	help
-	  Build the driver for RV110x Clock Driver.
+	  Build the driver for RV1106 Clock Driver.
+
+config CLK_RV1108
+	bool "Rockchip RV1108 clock controller support"
+	depends on ARM || COMPILE_TEST
+	default y
+	help
+	  Build the driver for RV1108 Clock Driver.
 
 config CLK_RV1126
 	bool "Rockchip RV1126 clock controller support"
diff --git a/drivers/clk/rockchip/Makefile b/drivers/clk/rockchip/Makefile
index 36894f6a7..2e80be11f 100644
--- a/drivers/clk/rockchip/Makefile
+++ b/drivers/clk/rockchip/Makefile
@@ -16,7 +16,8 @@ clk-rockchip-y += clk-ddr.o
 clk-rockchip-$(CONFIG_RESET_CONTROLLER) += softrst.o
 
 obj-$(CONFIG_CLK_PX30)          += clk-px30.o
-obj-$(CONFIG_CLK_RV110X)        += clk-rv1108.o
+obj-$(CONFIG_CLK_RV1106)        += clk-rv1106.o
+obj-$(CONFIG_CLK_RV1108)        += clk-rv1108.o
 obj-$(CONFIG_CLK_RV1126)        += clk-rv1126.o
 obj-$(CONFIG_CLK_RK3036)        += clk-rk3036.o
 obj-$(CONFIG_CLK_RK312X)        += clk-rk3128.o
diff --git a/drivers/clk/rockchip/clk-rv1106.c b/drivers/clk/rockchip/clk-rv1106.c
new file mode 100644
index 000000000..08e60715d
--- /dev/null
+++ b/drivers/clk/rockchip/clk-rv1106.c
@@ -0,0 +1,1244 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co. Ltd.
+ * Author: Elaine Zhang <zhangqing@rock-chips.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/syscore_ops.h>
+#include <dt-bindings/clock/rv1106-cru.h>
+#include "clk.h"
+
+#define CRU_PVTPLL0_CON0_L		0x11000
+#define CRU_PVTPLL0_CON0_H		0x11004
+#define CRU_PVTPLL0_CON1_L		0x11008
+#define CRU_PVTPLL0_CON1_H		0x1100c
+#define CRU_PVTPLL0_CON2_L		0x11010
+#define CRU_PVTPLL0_CON2_H		0x11014
+#define CRU_PVTPLL0_CON3_L		0x11018
+#define CRU_PVTPLL0_CON3_H		0x1101c
+#define CRU_PVTPLL0_OSC_CNT		0x11020
+#define CRU_PVTPLL0_OSC_CNT_AVG		0x11024
+
+#define CRU_PVTPLL1_CON0_L		0x11030
+#define CRU_PVTPLL1_CON0_H		0x11034
+#define CRU_PVTPLL1_CON1_L		0x11038
+#define CRU_PVTPLL1_CON1_H		0x1103c
+#define CRU_PVTPLL1_CON2_L		0x11040
+#define CRU_PVTPLL1_CON2_H		0x11044
+#define CRU_PVTPLL1_CON3_L		0x11048
+#define CRU_PVTPLL1_CON3_H		0x1104c
+#define CRU_PVTPLL1_OSC_CNT		0x11050
+#define CRU_PVTPLL1_OSC_CNT_AVG		0x11054
+
+#define RV1106_GRF_SOC_STATUS0		0x10
+#define CPU_PVTPLL_CON0_L		0x40000
+#define CPU_PVTPLL_CON0_H		0x40004
+#define CPU_PVTPLL_CON1			0x40008
+#define CPU_PVTPLL_CON2			0x4000c
+#define CPU_PVTPLL_CON3			0x40010
+#define CPU_PVTPLL_OSC_CNT		0x40018
+#define CPU_PVTPLL_OSC_CNT_AVG		0x4001c
+
+#define PVTPLL_RING_SEL_MASK		0x7
+#define PVTPLL_RING_SEL_SHIFT		8
+#define PVTPLL_EN_MASK			0x3
+#define PVTPLL_EN_SHIFT			0
+#define PVTPLL_LENGTH_SEL_MASK		0x7f
+#define PVTPLL_LENGTH_SEL_SHIFT		0
+
+#define CPU_CLK_PATH_BASE		(0x18300)
+#define CPU_PVTPLL_PATH_CORE		((1 << 12) | (1 << 28))
+
+#define RV1106_FRAC_MAX_PRATE		1200000000
+
+enum rv1106_plls {
+	apll, dpll, cpll, gpll,
+};
+
+static struct rockchip_pll_rate_table rv1106_pll_rates[] = {
+	/* _mhz, _refdiv, _fbdiv, _postdiv1, _postdiv2, _dsmpd, _frac */
+	RK3036_PLL_RATE(1608000000, 1, 67, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1600000000, 3, 200, 1, 1, 1, 0),
+	RK3036_PLL_RATE(1584000000, 1, 132, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1560000000, 1, 130, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1536000000, 1, 128, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1512000000, 1, 126, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1488000000, 1, 124, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1464000000, 1, 122, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1440000000, 1, 120, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1416000000, 1, 118, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1400000000, 3, 350, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1392000000, 1, 116, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1368000000, 1, 114, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1344000000, 1, 112, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1320000000, 1, 110, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1296000000, 1, 108, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1272000000, 1, 106, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1248000000, 1, 104, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1200000000, 1, 100, 2, 1, 1, 0),
+	RK3036_PLL_RATE(1188000000, 1, 99, 2, 1, 1, 0),
+	RK3036_PLL_RATE(700000000, 3, 350, 4, 1, 1, 0),
+	RK3036_PLL_RATE(696000000, 1, 116, 4, 1, 1, 0),
+	RK3036_PLL_RATE(624000000, 1, 104, 4, 1, 1, 0),
+	RK3036_PLL_RATE(600000000, 1, 100, 4, 1, 1, 0),
+	RK3036_PLL_RATE(594000000, 1, 99, 4, 1, 1, 0),
+	RK3036_PLL_RATE(504000000, 1, 84, 4, 1, 1, 0),
+	RK3036_PLL_RATE(500000000, 1, 125, 6, 1, 1, 0),
+	RK3036_PLL_RATE(496742400, 1, 124, 6, 1, 0, 3113851),
+	RK3036_PLL_RATE(491520000, 1, 40, 2, 1, 0, 16106127),
+	RK3036_PLL_RATE(408000000, 1, 68, 2, 2, 1, 0),
+	RK3036_PLL_RATE(312000000, 1, 78, 6, 1, 1, 0),
+	RK3036_PLL_RATE(216000000, 1, 72, 4, 2, 1, 0),
+	RK3036_PLL_RATE(96000000, 1, 96, 6, 4, 1, 0),
+	{ /* sentinel */ },
+};
+
+#define RV1106_DIV_ACLK_CORE_MASK	0x1f
+#define RV1106_DIV_ACLK_CORE_SHIFT	7
+#define RV1106_DIV_PCLK_DBG_MASK	0x1f
+#define RV1106_DIV_PCLK_DBG_SHIFT	0
+#define RV1106_CORE_SEL_MASK		0x3
+#define RV1106_CORE_SEL_SHIFT		5
+#define RV1106_ALT_DIV_MASK		0x1f
+#define RV1106_ALT_DIV_SHIFT		0
+
+#define RV1106_CLKSEL0(_aclk_core)					\
+{									\
+	.reg = RV1106_CORECLKSEL_CON(0),				\
+	.val = HIWORD_UPDATE(_aclk_core, RV1106_DIV_ACLK_CORE_MASK,	\
+			     RV1106_DIV_ACLK_CORE_SHIFT),		\
+}
+
+#define RV1106_CLKSEL1(_pclk_dbg)					\
+{									\
+	.reg = RV1106_CORECLKSEL_CON(1),				\
+	.val = HIWORD_UPDATE(_pclk_dbg, RV1106_DIV_PCLK_DBG_MASK,	\
+			     RV1106_DIV_PCLK_DBG_SHIFT),		\
+}
+
+#define RV1106_CLKSEL2(_is_pvtpll)					\
+{									\
+	.reg = RV1106_CORECLKSEL_CON(0),				\
+	.val = HIWORD_UPDATE(_is_pvtpll, RV1106_CORE_SEL_MASK,		\
+			     RV1106_CORE_SEL_SHIFT),			\
+}
+
+#define RV1106_CLKSEL3(_alt_div)					\
+{									\
+	.reg = RV1106_CORECLKSEL_CON(0),				\
+	.val = HIWORD_UPDATE(_alt_div, RV1106_ALT_DIV_MASK,		\
+			     RV1106_ALT_DIV_SHIFT),			\
+}
+
+#define RV1106_CPUCLK_RATE(_prate, _aclk_core, _pclk_dbg, _is_pvtpll)	\
+{									\
+	.prate = _prate,						\
+	.divs = {							\
+		RV1106_CLKSEL0(_aclk_core),				\
+		RV1106_CLKSEL1(_pclk_dbg),				\
+	},								\
+	.pre_muxs = {							\
+		RV1106_CLKSEL3(1),					\
+		RV1106_CLKSEL2(2),					\
+	},								\
+	.post_muxs = {							\
+		RV1106_CLKSEL2(_is_pvtpll),				\
+		RV1106_CLKSEL3(0),					\
+	},								\
+}
+
+static struct rockchip_cpuclk_rate_table rv1106_cpuclk_rates[] __initdata = {
+	RV1106_CPUCLK_RATE(1608000000, 3, 7, 1),
+	RV1106_CPUCLK_RATE(1584000000, 3, 7, 1),
+	RV1106_CPUCLK_RATE(1560000000, 3, 7, 1),
+	RV1106_CPUCLK_RATE(1536000000, 3, 7, 1),
+	RV1106_CPUCLK_RATE(1512000000, 3, 7, 1),
+	RV1106_CPUCLK_RATE(1488000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1464000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1440000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1416000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1392000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1368000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1344000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1320000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1296000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1272000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1248000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1224000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1200000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1104000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1096000000, 2, 5, 1),
+	RV1106_CPUCLK_RATE(1008000000, 1, 5, 1),
+	RV1106_CPUCLK_RATE(912000000, 1, 5, 1),
+	RV1106_CPUCLK_RATE(816000000, 1, 3, 1),
+	RV1106_CPUCLK_RATE(696000000, 1, 3, 0),
+	RV1106_CPUCLK_RATE(600000000, 1, 3, 0),
+	RV1106_CPUCLK_RATE(408000000, 1, 1, 0),
+	RV1106_CPUCLK_RATE(312000000, 1, 1, 0),
+	RV1106_CPUCLK_RATE(216000000,  1, 1, 0),
+	RV1106_CPUCLK_RATE(96000000, 1, 1, 0),
+};
+
+static const struct rockchip_cpuclk_reg_data rv1106_cpuclk_data = {
+	.core_reg[0] = RV1106_CORECLKSEL_CON(0),
+	.div_core_shift[0] = 0,
+	.div_core_mask[0] = 0x1f,
+	.num_cores = 1,
+	.mux_core_alt = 2,
+	.mux_core_main = 2,
+	.mux_core_shift = 5,
+	.mux_core_mask = 0x3,
+};
+
+PNAME(mux_pll_p)			= { "xin24m" };
+PNAME(mux_24m_32k_p)			= { "xin24m", "clk_rtc_32k" };
+PNAME(mux_armclk_p)			= { "gpll", "cpll", "apll" };
+PNAME(mux_gpll_cpll_p)			= { "gpll", "cpll" };
+PNAME(mux_gpll_24m_p)			= { "gpll", "xin24m" };
+PNAME(mux_100m_50m_24m_p)		= { "clk_100m_src", "clk_50m_src", "xin24m" };
+PNAME(mux_150m_100m_50m_24m_p)		= { "clk_150m_src", "clk_100m_src", "clk_50m_src", "xin24m" };
+PNAME(mux_500m_300m_100m_24m_p)		= { "clk_500m_src", "clk_300m_src", "clk_100m_src", "xin24m" };
+PNAME(mux_400m_300m_pvtpll0_pvtpll1_p)	= { "clk_400m_src", "clk_300m_src", "clk_pvtpll_0", "clk_pvtpll_1" };
+PNAME(mux_500m_300m_pvtpll0_pvtpll1_p)	= { "clk_500m_src", "clk_300m_src", "clk_pvtpll_0", "clk_pvtpll_1" };
+PNAME(mux_339m_200m_pvtpll0_pvtpll1_p)	= { "clk_339m_src", "clk_200m_src", "clk_pvtpll_0", "clk_pvtpll_1" };
+PNAME(mux_400m_200m_100m_24m_p)		= { "clk_400m_src", "clk_200m_src", "clk_100m_src", "xin24m" };
+PNAME(mux_200m_100m_50m_24m_p)		= { "clk_200m_src", "clk_100m_src", "clk_50m_src", "xin24m" };
+PNAME(mux_300m_200m_100m_24m_p)		= { "clk_300m_src", "clk_200m_src", "clk_100m_src", "xin24m" };
+PNAME(mux_500m_300m_200m_24m_p)		= { "clk_500m_src", "clk_300m_src", "clk_200m_src", "xin24m" };
+PNAME(mux_50m_24m_p)			= { "clk_50m_src", "xin24m" };
+PNAME(mux_400m_24m_p)			= { "clk_400m_src", "xin24m" };
+PNAME(clk_rtc32k_pmu_p)			= { "clk_rtc32k_frac", "xin32k", "clk_pvtm_32k" };
+PNAME(mux_200m_100m_24m_32k_p)		= { "clk_200m_src", "clk_100m_src", "xin24m", "clk_rtc_32k" };
+PNAME(mux_100m_pmu_24m_p)		= { "clk_100m_pmu", "xin24m" };
+PNAME(mux_200m_100m_24m_p)		= { "clk_200m_src", "clk_100m_pmu", "xin24m" };
+PNAME(mux_339m_200m_100m_24m_p)		= { "clk_339m_src", "clk_200m_src", "clk_100m_pmu", "xin24m" };
+PNAME(mux_dpll_300m_p)			= { "dpll", "clk_300m_src" };
+PNAME(clk_i2s0_8ch_tx_p)		= { "clk_i2s0_8ch_tx_src", "clk_i2s0_8ch_tx_frac", "i2s0_mclkin", "xin_osc0_half" };
+PNAME(clk_i2s0_8ch_rx_p)		= { "clk_i2s0_8ch_rx_src", "clk_i2s0_8ch_rx_frac", "i2s0_mclkin", "xin_osc0_half" };
+PNAME(i2s0_8ch_mclkout_p)		= { "mclk_i2s0_8ch_tx", "mclk_i2s0_8ch_rx", "xin_osc0_half" };
+PNAME(clk_ref_mipi0_p)			= { "clk_ref_mipi0_src", "clk_ref_mipi0_frac", "xin24m" };
+PNAME(clk_ref_mipi1_p)			= { "clk_ref_mipi1_src", "clk_ref_mipi1_frac", "xin24m" };
+PNAME(clk_uart0_p)			= { "clk_uart0_src", "clk_uart0_frac", "xin24m" };
+PNAME(clk_uart1_p)			= { "clk_uart1_src", "clk_uart1_frac", "xin24m" };
+PNAME(clk_uart2_p)			= { "clk_uart2_src", "clk_uart2_frac", "xin24m" };
+PNAME(clk_uart3_p)			= { "clk_uart3_src", "clk_uart3_frac", "xin24m" };
+PNAME(clk_uart4_p)			= { "clk_uart4_src", "clk_uart4_frac", "xin24m" };
+PNAME(clk_uart5_p)			= { "clk_uart5_src", "clk_uart5_frac", "xin24m" };
+PNAME(clk_vicap_m0_p)			= { "clk_vicap_m0_src", "clk_vicap_m0_frac", "xin24m" };
+PNAME(clk_vicap_m1_p)			= { "clk_vicap_m1_src", "clk_vicap_m1_frac", "xin24m" };
+
+static struct rockchip_pll_clock rv1106_pll_clks[] __initdata = {
+	[apll] = PLL(pll_rk3328, PLL_APLL, "apll", mux_pll_p,
+		     CLK_IGNORE_UNUSED, RV1106_PLL_CON(0),
+		     RV1106_MODE_CON, 0, 10, 0, rv1106_pll_rates),
+	[cpll] = PLL(pll_rk3328, PLL_CPLL, "cpll", mux_pll_p,
+		     0, RV1106_PLL_CON(8),
+		     RV1106_MODE_CON, 2, 10, 0, rv1106_pll_rates),
+	[dpll] = PLL(pll_rk3328, PLL_DPLL, "dpll", mux_pll_p,
+		     CLK_IGNORE_UNUSED, RV1106_PLL_CON(16),
+		     RV1106_SUBDDRMODE_CON, 0, 10, 0, NULL),
+	[gpll] = PLL(pll_rk3328, PLL_GPLL, "gpll", mux_pll_p,
+		     0, RV1106_PLL_CON(24),
+		     RV1106_MODE_CON, 4, 10, 0, rv1106_pll_rates),
+};
+
+#define MFLAGS CLK_MUX_HIWORD_MASK
+#define DFLAGS CLK_DIVIDER_HIWORD_MASK
+#define GFLAGS (CLK_GATE_HIWORD_MASK | CLK_GATE_SET_TO_DISABLE)
+
+static struct rockchip_clk_branch rv1106_rtc32k_pmu_fracmux __initdata =
+	MUX(CLK_RTC_32K, "clk_rtc_32k", clk_rtc32k_pmu_p, CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT,
+			RV1106_PMUCLKSEL_CON(0), 6, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_i2s0_8ch_tx_fracmux __initdata =
+	MUX(CLK_I2S0_8CH_TX, "clk_i2s0_8ch_tx", clk_i2s0_8ch_tx_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(19), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_i2s0_8ch_rx_fracmux __initdata =
+	MUX(CLK_I2S0_8CH_RX, "clk_i2s0_8ch_rx", clk_i2s0_8ch_rx_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(21), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_ref_mipi0_fracmux __initdata =
+	MUX(CLK_REF_MIPI0, "clk_ref_mipi0", clk_ref_mipi0_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(27), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_ref_mipi1_fracmux __initdata =
+	MUX(CLK_REF_MIPI1, "clk_ref_mipi1", clk_ref_mipi1_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(29), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_uart0_fracmux __initdata =
+	MUX(CLK_UART0, "clk_uart0", clk_uart0_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(7), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_uart1_fracmux __initdata =
+	MUX(CLK_UART1, "clk_uart1", clk_uart1_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(9), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_uart2_fracmux __initdata =
+	MUX(CLK_UART2, "clk_uart2", clk_uart2_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(11), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_uart3_fracmux __initdata =
+	MUX(CLK_UART3, "clk_uart3", clk_uart3_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(13), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_uart4_fracmux __initdata =
+	MUX(CLK_UART4, "clk_uart4", clk_uart4_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(15), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_uart5_fracmux __initdata =
+	MUX(CLK_UART5, "clk_uart5", clk_uart5_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(17), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_vicap_m0_fracmux __initdata =
+	MUX(CLK_VICAP_M0, "clk_vicap_m0", clk_vicap_m0_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(31), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_vicap_m1_fracmux __initdata =
+	MUX(CLK_VICAP_M1, "clk_vicap_m1", clk_vicap_m1_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(33), 0, 2, MFLAGS);
+
+static struct rockchip_clk_branch rv1106_clk_branches[] __initdata = {
+
+	FACTOR(0, "xin_osc0_half", "xin24m", 0, 1, 2),
+
+	/* PD_CORE */
+	GATE(CLK_PVTM_CORE, "clk_pvtm_core", "xin24m", 0,
+			RV1106_CORECLKGATE_CON(0), 14, GFLAGS),
+	GATE(CLK_CORE_MCU_RTC, "clk_core_mcu_rtc", "xin24m", 0,
+			RV1106_CORECLKGATE_CON(1), 6, GFLAGS),
+	COMPOSITE(HCLK_CPU, "hclk_cpu", mux_gpll_24m_p, CLK_IS_CRITICAL,
+			RV1106_CORECLKSEL_CON(2), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CORECLKGATE_CON(0), 12, GFLAGS),
+	COMPOSITE(CLK_CORE_MCU, "clk_core_mcu", mux_gpll_24m_p, 0,
+			RV1106_CORECLKSEL_CON(3), 11, 1, MFLAGS, 6, 5, DFLAGS,
+			RV1106_CORECLKGATE_CON(1), 1, GFLAGS),
+	COMPOSITE_NOMUX(0, "pclk_dbg", "armclk", CLK_IS_CRITICAL,
+			RV1106_CORECLKSEL_CON(1), 0, 5, DFLAGS | CLK_DIVIDER_READ_ONLY,
+			RV1106_CORECLKGATE_CON(0), 6, GFLAGS),
+	GATE(0, "pclk_cpu_root", "pclk_dbg", CLK_IS_CRITICAL,
+			RV1106_CORECLKGATE_CON(0), 10, GFLAGS),
+	GATE(PCLK_MAILBOX, "pclk_mailbox", "pclk_cpu_root", 0,
+			RV1106_CORECLKGATE_CON(1), 8, GFLAGS),
+
+	/* PD _TOP */
+	COMPOSITE(CLK_50M_SRC, "clk_50m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(0), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE(CLK_100M_SRC, "clk_100m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(0), 11, 1, MFLAGS, 6, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 2, GFLAGS),
+	COMPOSITE(CLK_150M_SRC, "clk_150m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(1), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 3, GFLAGS),
+	COMPOSITE(CLK_200M_SRC, "clk_200m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(1), 11, 1, MFLAGS, 6, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 4, GFLAGS),
+	COMPOSITE(CLK_250M_SRC, "clk_250m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(2), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 5, GFLAGS),
+	COMPOSITE(CLK_300M_SRC, "clk_300m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(2), 11, 1, MFLAGS, 6, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 6, GFLAGS),
+	COMPOSITE_HALFDIV(CLK_339M_SRC, "clk_339m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(3), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 7, GFLAGS),
+	COMPOSITE(CLK_400M_SRC, "clk_400m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(3), 11, 1, MFLAGS, 6, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 8, GFLAGS),
+	COMPOSITE_HALFDIV(CLK_450M_SRC, "clk_450m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(4), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 9, GFLAGS),
+	COMPOSITE(CLK_500M_SRC, "clk_500m_src", mux_gpll_cpll_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(4), 11, 1, MFLAGS, 6, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 10, GFLAGS),
+
+	COMPOSITE_NODIV(PCLK_TOP_ROOT, "pclk_top_root", mux_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_CLKSEL_CON(24), 5, 2, MFLAGS,
+			RV1106_CLKGATE_CON(2), 9, GFLAGS),
+
+	COMPOSITE(CLK_I2S0_8CH_TX_SRC, "clk_i2s0_8ch_tx_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(17), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(1), 13, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_I2S0_8CH_TX_FRAC, "clk_i2s0_8ch_tx_frac", "clk_i2s0_8ch_tx_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(18), 0,
+			RV1106_CLKGATE_CON(1), 14, GFLAGS,
+			&rv1106_i2s0_8ch_tx_fracmux),
+	GATE(MCLK_I2S0_8CH_TX, "mclk_i2s0_8ch_tx", "clk_i2s0_8ch_tx", 0,
+			RV1106_CLKGATE_CON(1), 15, GFLAGS),
+	COMPOSITE(CLK_I2S0_8CH_RX_SRC, "clk_i2s0_8ch_rx_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(19), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(2), 0, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_I2S0_8CH_RX_FRAC, "clk_i2s0_8ch_rx_frac", "clk_i2s0_8ch_rx_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(20), 0,
+			RV1106_CLKGATE_CON(2), 1, GFLAGS,
+			&rv1106_i2s0_8ch_rx_fracmux),
+	GATE(MCLK_I2S0_8CH_RX, "mclk_i2s0_8ch_rx", "clk_i2s0_8ch_rx", 0,
+			RV1106_CLKGATE_CON(2), 2, GFLAGS),
+	MUX(I2S0_8CH_MCLKOUT, "i2s0_8ch_mclkout", i2s0_8ch_mclkout_p, CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(21), 2, 2, MFLAGS),
+	COMPOSITE(CLK_REF_MIPI0_SRC, "clk_ref_mipi0_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(25), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(3), 4, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_REF_MIPI0_FRAC, "clk_ref_mipi0_frac", "clk_ref_mipi0_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(26), 0,
+			RV1106_CLKGATE_CON(3), 5, GFLAGS,
+			&rv1106_clk_ref_mipi0_fracmux),
+	GATE(MCLK_REF_MIPI0, "mclk_ref_mipi0", "clk_ref_mipi0", 0,
+			 RV1106_CLKGATE_CON(3), 6, GFLAGS),
+	COMPOSITE(CLK_REF_MIPI1_SRC, "clk_ref_mipi1_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(27), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(3), 7, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_REF_MIPI1_FRAC, "clk_ref_mipi1_frac", "clk_ref_mipi1_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(28), 0,
+			RV1106_CLKGATE_CON(3), 8, GFLAGS,
+			&rv1106_clk_ref_mipi1_fracmux),
+	GATE(MCLK_REF_MIPI1, "mclk_ref_mipi1", "clk_ref_mipi1", 0,
+			 RV1106_CLKGATE_CON(3), 9, GFLAGS),
+	COMPOSITE(CLK_UART0_SRC, "clk_uart0_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(5), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 11, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_UART0_FRAC, "clk_uart0_frac", "clk_uart0_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(6), CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,
+			RV1106_CLKGATE_CON(0), 12, GFLAGS,
+			&rv1106_clk_uart0_fracmux),
+	GATE(SCLK_UART0, "sclk_uart0", "clk_uart0", 0,
+			RV1106_CLKGATE_CON(0), 13, GFLAGS),
+	COMPOSITE(CLK_UART1_SRC, "clk_uart1_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(7), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(0), 14, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_UART1_FRAC, "clk_uart1_frac", "clk_uart1_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(8), CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,
+			RV1106_CLKGATE_CON(0), 15, GFLAGS,
+			&rv1106_clk_uart1_fracmux),
+	GATE(SCLK_UART1, "sclk_uart1", "clk_uart1", 0,
+			 RV1106_CLKGATE_CON(1), 0, GFLAGS),
+	COMPOSITE(CLK_UART2_SRC, "clk_uart2_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(9), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(1), 1, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_UART2_FRAC, "clk_uart2_frac", "clk_uart2_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(10), CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,
+			RV1106_CLKGATE_CON(1), 2, GFLAGS,
+			&rv1106_clk_uart2_fracmux),
+	GATE(SCLK_UART2, "sclk_uart2", "clk_uart2", 0,
+			 RV1106_CLKGATE_CON(1), 3, GFLAGS),
+	COMPOSITE(CLK_UART3_SRC, "clk_uart3_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(11), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(1), 4, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_UART3_FRAC, "clk_uart3_frac", "clk_uart3_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(12), CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,
+			RV1106_CLKGATE_CON(1), 5, GFLAGS,
+			&rv1106_clk_uart3_fracmux),
+	GATE(SCLK_UART3, "sclk_uart3", "clk_uart3", 0,
+			 RV1106_CLKGATE_CON(1), 6, GFLAGS),
+	COMPOSITE(CLK_UART4_SRC, "clk_uart4_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(13), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(1), 7, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_UART4_FRAC, "clk_uart4_frac", "clk_uart4_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(14), CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,
+			RV1106_CLKGATE_CON(1), 8, GFLAGS,
+			&rv1106_clk_uart4_fracmux),
+	GATE(SCLK_UART4, "sclk_uart4", "clk_uart4", 0,
+			 RV1106_CLKGATE_CON(1), 9, GFLAGS),
+	COMPOSITE(CLK_UART5_SRC, "clk_uart5_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(15), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(1), 10, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_UART5_FRAC, "clk_uart5_frac", "clk_uart5_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(16), CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,
+			RV1106_CLKGATE_CON(1), 11, GFLAGS,
+			&rv1106_clk_uart5_fracmux),
+	GATE(SCLK_UART5, "sclk_uart5", "clk_uart5", 0,
+			 RV1106_CLKGATE_CON(1), 12, GFLAGS),
+	COMPOSITE(CLK_VICAP_M0_SRC, "clk_vicap_m0_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(29), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(3), 10, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_VICAP_M0_FRAC, "clk_vicap_m0_frac", "clk_vicap_m0_src", CLK_SET_RATE_PARENT,
+			RV1106_CLKSEL_CON(30), 0,
+			RV1106_CLKGATE_CON(3), 11, GFLAGS,
+			&rv1106_clk_vicap_m0_fracmux),
+	GATE(SCLK_VICAP_M0, "sclk_vicap_m0", "clk_vicap_m0", 0,
+			 RV1106_CLKGATE_CON(3), 12, GFLAGS),
+	COMPOSITE(CLK_VICAP_M1_SRC, "clk_vicap_m1_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(31), 7, 1, MFLAGS, 2, 5, DFLAGS,
+			RV1106_CLKGATE_CON(3), 13, GFLAGS),
+	COMPOSITE_FRACMUX(CLK_VICAP_M1_FRAC, "clk_vicap_m1_frac", "clk_vicap_m1_src", 0,
+			RV1106_CLKSEL_CON(32), 0,
+			RV1106_CLKGATE_CON(3), 14, GFLAGS,
+			&rv1106_clk_vicap_m1_fracmux),
+	GATE(SCLK_VICAP_M1, "sclk_vicap_m1", "clk_vicap_m1", 0,
+			 RV1106_CLKGATE_CON(3), 15, GFLAGS),
+	COMPOSITE(DCLK_VOP_SRC, "dclk_vop_src", mux_gpll_cpll_p, 0,
+			RV1106_CLKSEL_CON(23), 8, 1, MFLAGS, 3, 5, DFLAGS,
+			RV1106_CLKGATE_CON(2), 6, GFLAGS),
+
+	/* PD_DDR */
+	COMPOSITE_NODIV(PCLK_DDR_ROOT, "pclk_ddr_root", mux_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_DDRCLKSEL_CON(0), 0, 2, MFLAGS,
+			RV1106_DDRCLKGATE_CON(0), 0, GFLAGS),
+	COMPOSITE_NODIV(ACLK_DDR_ROOT, "aclk_ddr_root", mux_500m_300m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_DDRCLKSEL_CON(0), 8, 2, MFLAGS,
+			RV1106_DDRCLKGATE_CON(0), 12, GFLAGS),
+	GATE(PCLK_DDRPHY, "pclk_ddrphy", "pclk_ddr_root", CLK_IGNORE_UNUSED,
+			RV1106_DDRCLKGATE_CON(1), 3, GFLAGS),
+	GATE(PCLK_DDR_HWLP, "pclk_ddr_hwlp", "pclk_ddr_root", CLK_IGNORE_UNUSED,
+			RV1106_DDRCLKGATE_CON(1), 2, GFLAGS),
+	GATE(PCLK_DDRMON, "pclk_ddrmon", "pclk_ddr_root", 0,
+			RV1106_DDRCLKGATE_CON(0), 7, GFLAGS),
+	GATE(CLK_TIMER_DDRMON, "clk_timer_ddrmon", "xin24m", 0,
+			RV1106_DDRCLKGATE_CON(0), 8, GFLAGS),
+	GATE(PCLK_DDRC, "pclk_ddrc", "pclk_ddr_root", CLK_IGNORE_UNUSED,
+			RV1106_DDRCLKGATE_CON(0), 5, GFLAGS),
+	GATE(PCLK_DFICTRL, "pclk_dfictrl", "pclk_ddr_root", CLK_IS_CRITICAL,
+			RV1106_DDRCLKGATE_CON(0), 11, GFLAGS),
+	GATE(ACLK_SYS_SHRM, "aclk_sys_shrm", "aclk_ddr_root", CLK_IS_CRITICAL,
+			RV1106_DDRCLKGATE_CON(0), 13, GFLAGS),
+
+	/* PD_NPU */
+	COMPOSITE_NODIV(HCLK_NPU_ROOT, "hclk_npu_root", mux_150m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_NPUCLKSEL_CON(0), 0, 2, MFLAGS,
+			RV1106_NPUCLKGATE_CON(0), 0, GFLAGS),
+	COMPOSITE_NODIV(ACLK_NPU_ROOT, "aclk_npu_root", mux_500m_300m_pvtpll0_pvtpll1_p, CLK_IS_CRITICAL,
+			RV1106_NPUCLKSEL_CON(0), 2, 2, MFLAGS,
+			RV1106_NPUCLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE_NODIV(PCLK_NPU_ROOT, "pclk_npu_root", mux_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_NPUCLKSEL_CON(0), 4, 2, MFLAGS,
+			RV1106_NPUCLKGATE_CON(0), 2, GFLAGS),
+	GATE(HCLK_RKNN, "hclk_rknn", "hclk_npu_root", 0,
+			RV1106_NPUCLKGATE_CON(0), 9, GFLAGS),
+	GATE(ACLK_RKNN, "aclk_rknn", "aclk_npu_root", 0,
+			RV1106_NPUCLKGATE_CON(0), 10, GFLAGS),
+
+	/* PD_PERI */
+	COMPOSITE_NODIV(PCLK_PERI_ROOT, "pclk_peri_root", mux_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_PERICLKSEL_CON(1), 0, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(0), 0, GFLAGS),
+	COMPOSITE_NODIV(ACLK_PERI_ROOT, "aclk_peri_root", mux_400m_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_PERICLKSEL_CON(1), 2, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE_NODIV(HCLK_PERI_ROOT, "hclk_peri_root", mux_200m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_PERICLKSEL_CON(1), 4, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(0), 2, GFLAGS),
+	COMPOSITE_NODIV(ACLK_BUS_ROOT, "aclk_bus_root", mux_300m_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_PERICLKSEL_CON(9), 0, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(6), 8, GFLAGS),
+	GATE(PCLK_ACODEC, "pclk_acodec", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 3, GFLAGS),
+	COMPOSITE_NOMUX(MCLK_ACODEC_TX, "mclk_acodec_tx", "mclk_i2s0_8ch_tx", 0,
+			RV1106_PERICLKSEL_CON(8), 0, 8, DFLAGS,
+			RV1106_PERICLKGATE_CON(6), 4, GFLAGS),
+	COMPOSITE_NODIV(CLK_CORE_CRYPTO, "clk_core_crypto", mux_300m_200m_100m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(6), 5, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(3), 11, GFLAGS),
+	COMPOSITE_NODIV(CLK_PKA_CRYPTO, "clk_pka_crypto", mux_300m_200m_100m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(6), 7, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(3), 12, GFLAGS),
+	GATE(ACLK_CRYPTO, "aclk_crypto", "aclk_bus_root", 0,
+			RV1106_PERICLKGATE_CON(3), 13, GFLAGS),
+	GATE(HCLK_CRYPTO, "hclk_crypto", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(3), 14, GFLAGS),
+	GATE(ACLK_DECOM, "aclk_decom", "aclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(5), 9, GFLAGS),
+	GATE(PCLK_DECOM, "pclk_decom", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(5), 10, GFLAGS),
+	COMPOSITE_NODIV(DCLK_DECOM, "dclk_decom", mux_400m_200m_100m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(7), 14, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(5), 11, GFLAGS),
+	GATE(ACLK_DMAC, "aclk_dmac", "aclk_bus_root", 0,
+			RV1106_PERICLKGATE_CON(5), 8, GFLAGS),
+	GATE(PCLK_DSM, "pclk_dsm", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 2, GFLAGS),
+	GATE(MCLK_DSM, "mclk_dsm", "mclk_i2s0_8ch_tx", 0,
+			RV1106_PERICLKGATE_CON(6), 1, GFLAGS),
+	COMPOSITE(CCLK_SRC_EMMC, "cclk_src_emmc", mux_400m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(7), 6, 1, MFLAGS, 0, 6, DFLAGS,
+			RV1106_PERICLKGATE_CON(4), 12, GFLAGS),
+	GATE(HCLK_EMMC, "hclk_emmc", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(4), 13, GFLAGS),
+	GATE(PCLK_GPIO4, "pclk_gpio4", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(2), 0, GFLAGS),
+	GATE(DBCLK_GPIO4, "dbclk_gpio4", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(2), 1, GFLAGS),
+	GATE(PCLK_I2C0, "pclk_i2c0", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(1), 6, GFLAGS),
+	COMPOSITE_NODIV(CLK_I2C0, "clk_i2c0", mux_200m_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(1), 8, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(1), 7, GFLAGS),
+	GATE(PCLK_I2C2, "pclk_i2c2", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(1), 10, GFLAGS),
+	COMPOSITE_NODIV(CLK_I2C2, "clk_i2c2", mux_200m_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(1), 12, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(1), 11, GFLAGS),
+	GATE(PCLK_I2C3, "pclk_i2c3", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(1), 12, GFLAGS),
+	COMPOSITE_NODIV(CLK_I2C3, "clk_i2c3", mux_200m_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(1), 14, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(1), 13, GFLAGS),
+	GATE(PCLK_I2C4, "pclk_i2c4", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(1), 14, GFLAGS),
+	COMPOSITE_NODIV(CLK_I2C4, "clk_i2c4", mux_200m_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(2), 0, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(1), 15, GFLAGS),
+	GATE(HCLK_I2S0, "hclk_i2s0", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 0, GFLAGS),
+	GATE(PCLK_DFT2APB, "pclk_dft2apb", "pclk_peri_root", CLK_IGNORE_UNUSED,
+			RV1106_PERICLKGATE_CON(6), 7, GFLAGS),
+	GATE(HCLK_IVE, "hclk_ive", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 9, GFLAGS),
+	GATE(ACLK_IVE, "aclk_ive", "aclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 10, GFLAGS),
+	GATE(PCLK_PWM0_PERI, "pclk_pwm0_peri", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(7), 3, GFLAGS),
+	COMPOSITE_NODIV(CLK_PWM0_PERI, "clk_pwm0_peri", mux_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(11), 0, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(7), 4, GFLAGS),
+	GATE(CLK_CAPTURE_PWM0_PERI, "clk_capture_pwm0_peri", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(7), 5, GFLAGS),
+	GATE(CLK_TIMER_ROOT, "clk_timer_root", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(0), 3, GFLAGS),
+	GATE(HCLK_SFC, "hclk_sfc", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(4), 14, GFLAGS),
+	COMPOSITE(SCLK_SFC, "sclk_sfc", mux_500m_300m_200m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(7), 12, 2, MFLAGS, 7, 5, DFLAGS,
+			RV1106_PERICLKGATE_CON(5), 0, GFLAGS),
+	GATE(PCLK_UART0, "pclk_uart0", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 11, GFLAGS),
+	GATE(PCLK_UART1, "pclk_uart1", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(6), 15, GFLAGS),
+	GATE(PCLK_PWM1_PERI, "pclk_pwm1_peri", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(3), 15, GFLAGS),
+	COMPOSITE_NODIV(CLK_PWM1_PERI, "clk_pwm1_peri", mux_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(6), 9, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(4), 0, GFLAGS),
+	GATE(CLK_CAPTURE_PWM1_PERI, "clk_capture_pwm1_peri", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(4), 1, GFLAGS),
+	GATE(PCLK_PWM2_PERI, "pclk_pwm2_peri", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(4), 2, GFLAGS),
+	COMPOSITE_NODIV(CLK_PWM2_PERI, "clk_pwm2_peri", mux_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(6), 11, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(4), 3, GFLAGS),
+	GATE(CLK_CAPTURE_PWM2_PERI, "clk_capture_pwm2_peri", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(4), 4, GFLAGS),
+	GATE(HCLK_BOOTROM, "hclk_bootrom", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(0), 7, GFLAGS),
+	GATE(HCLK_SAI, "hclk_sai", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(5), 13, GFLAGS),
+	GATE(MCLK_SAI, "mclk_sai", "mclk_i2s0_8ch_tx", 0,
+			RV1106_PERICLKGATE_CON(5), 14, GFLAGS),
+	GATE(PCLK_SARADC, "pclk_saradc", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(3), 3, GFLAGS),
+	COMPOSITE_NOMUX(CLK_SARADC, "clk_saradc", "xin24m", 0,
+			RV1106_PERICLKSEL_CON(6), 0, 3, DFLAGS,
+			RV1106_PERICLKGATE_CON(3), 4, GFLAGS),
+	GATE(PCLK_SPI1, "pclk_spi1", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(3), 6, GFLAGS),
+	COMPOSITE_NODIV(CLK_SPI1, "clk_spi1", mux_200m_100m_50m_24m_p, 0,
+			RV1106_PERICLKSEL_CON(6), 3, 2, MFLAGS,
+			RV1106_PERICLKGATE_CON(3), 7, GFLAGS),
+	GATE(PCLK_STIMER, "pclk_stimer", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(0), 15, GFLAGS),
+	GATE(CLK_STIMER0, "clk_stimer0", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(1), 0, GFLAGS),
+	GATE(CLK_STIMER1, "clk_stimer1", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(1), 1, GFLAGS),
+	GATE(PCLK_TIMER, "pclk_timer", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(0), 8, GFLAGS),
+	GATE(CLK_TIMER0, "clk_timer0", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(0), 9, GFLAGS),
+	GATE(CLK_TIMER1, "clk_timer1", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(0), 10, GFLAGS),
+	GATE(CLK_TIMER2, "clk_timer2", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(0), 11, GFLAGS),
+	GATE(CLK_TIMER3, "clk_timer3", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(0), 12, GFLAGS),
+	GATE(CLK_TIMER4, "clk_timer4", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(0), 13, GFLAGS),
+	GATE(CLK_TIMER5, "clk_timer5", "clk_timer_root", 0,
+			RV1106_PERICLKGATE_CON(0), 14, GFLAGS),
+	GATE(HCLK_TRNG_NS, "hclk_trng_ns", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(3), 9, GFLAGS),
+	GATE(HCLK_TRNG_S, "hclk_trng_s", "hclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(3), 10, GFLAGS),
+	GATE(PCLK_UART2, "pclk_uart2", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(2), 3, GFLAGS),
+	GATE(PCLK_UART3, "pclk_uart3", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(2), 7, GFLAGS),
+	GATE(PCLK_UART4, "pclk_uart4", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(2), 11, GFLAGS),
+	GATE(PCLK_UART5, "pclk_uart5", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(2), 15, GFLAGS),
+	GATE(ACLK_USBOTG, "aclk_usbotg", "aclk_bus_root", 0,
+			RV1106_PERICLKGATE_CON(4), 7, GFLAGS),
+	GATE(CLK_REF_USBOTG, "clk_ref_usbotg", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(4), 8, GFLAGS),
+	GATE(PCLK_USBPHY, "pclk_usbphy", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(5), 1, GFLAGS),
+	GATE(CLK_REF_USBPHY, "clk_ref_usbphy", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(5), 2, GFLAGS),
+	GATE(PCLK_WDT_NS, "pclk_wdt_ns", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(1), 2, GFLAGS),
+	GATE(TCLK_WDT_NS, "tclk_wdt_ns", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(1), 3, GFLAGS),
+	GATE(PCLK_WDT_S, "pclk_wdt_s", "pclk_peri_root", 0,
+			RV1106_PERICLKGATE_CON(1), 4, GFLAGS),
+	GATE(TCLK_WDT_S, "tclk_wdt_s", "xin24m", 0,
+			RV1106_PERICLKGATE_CON(1), 5, GFLAGS),
+
+	/* PD_PMU */
+	COMPOSITE_FRACMUX(0, "clk_rtc32k_frac", "xin24m", CLK_IGNORE_UNUSED,
+			RV1106_PMUCLKSEL_CON(6), 0,
+			RV1106_PMUCLKGATE_CON(1), 14, GFLAGS,
+			&rv1106_rtc32k_pmu_fracmux),
+	DIV(CLK_100M_PMU, "clk_100m_pmu", "clk_200m_src", 0,
+			RV1106_PMUCLKSEL_CON(0), 0, 3, DFLAGS),
+	COMPOSITE_NODIV(PCLK_PMU_ROOT, "pclk_pmu_root", mux_100m_pmu_24m_p, CLK_IS_CRITICAL,
+			RV1106_PMUCLKSEL_CON(0), 3, 1, MFLAGS,
+			RV1106_PMUCLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE_NODIV(HCLK_PMU_ROOT, "hclk_pmu_root", mux_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_PMUCLKSEL_CON(0), 4, 2, MFLAGS,
+			RV1106_PMUCLKGATE_CON(0), 2, GFLAGS),
+	GATE(CLK_PMU, "clk_pmu", "xin24m", CLK_IS_CRITICAL,
+			RV1106_PMUCLKGATE_CON(1), 0, GFLAGS),
+	GATE(PCLK_PMU, "pclk_pmu", "pclk_pmu_root", CLK_IS_CRITICAL,
+			RV1106_PMUCLKGATE_CON(1), 1, GFLAGS),
+	GATE(CLK_DDR_FAIL_SAFE, "clk_ddr_fail_safe", "clk_pmu", 0,
+			RV1106_PMUCLKGATE_CON(1), 15, GFLAGS),
+	GATE(PCLK_PMU_GPIO0, "pclk_pmu_gpio0", "pclk_pmu_root", 0,
+			RV1106_PMUCLKGATE_CON(1), 2, GFLAGS),
+	COMPOSITE_NODIV(DBCLK_PMU_GPIO0, "dbclk_pmu_gpio0", mux_24m_32k_p, 0,
+			RV1106_PMUCLKSEL_CON(0), 15, 1, MFLAGS,
+			RV1106_PMUCLKGATE_CON(1), 3, GFLAGS),
+	GATE(PCLK_I2C1, "pclk_i2c1", "pclk_pmu_root", 0,
+			RV1106_PMUCLKGATE_CON(0), 3, GFLAGS),
+	COMPOSITE_NODIV(CLK_I2C1, "clk_i2c1", mux_200m_100m_24m_32k_p, 0,
+			RV1106_PMUCLKSEL_CON(0), 6, 2, MFLAGS,
+			RV1106_PMUCLKGATE_CON(0), 4, GFLAGS),
+	GATE(PCLK_PMU_MAILBOX, "pclk_pmu_mailbox", "pclk_pmu_root", 0,
+			RV1106_PMUCLKGATE_CON(2), 10, GFLAGS),
+	GATE(CLK_PMU_MCU, "clk_pmu_mcu", "hclk_pmu_root", 0,
+			RV1106_PMUCLKGATE_CON(0), 9, GFLAGS),
+	GATE(CLK_PMU_MCU_RTC, "clk_pmu_mcu_rtc", "xin24m", 0,
+			RV1106_PMUCLKGATE_CON(0), 13, GFLAGS),
+	COMPOSITE_NOMUX(CLK_PVTM_PMU, "clk_pvtm_pmu", "xin24m", 0,
+			RV1106_PMUCLKSEL_CON(1), 0, 5, DFLAGS,
+			RV1106_PMUCLKGATE_CON(1), 4, GFLAGS),
+	GATE(PCLK_PVTM_PMU, "pclk_pvtm_pmu", "pclk_pmu_root", 0,
+			RV1106_PMUCLKGATE_CON(1), 5, GFLAGS),
+	GATE(CLK_REFOUT, "clk_refout", "xin24m", 0,
+			RV1106_PMUCLKGATE_CON(2), 13, GFLAGS),
+	GATE(HCLK_PMU_SRAM, "hclk_pmu_sram", "hclk_pmu_root", CLK_IGNORE_UNUSED,
+			RV1106_PMUCLKGATE_CON(0), 8, GFLAGS),
+	GATE(PCLK_PMU_WDT, "pclk_pmu_wdt", "pclk_pmu_root", 0,
+			RV1106_PMUCLKGATE_CON(2), 8, GFLAGS),
+	COMPOSITE_NODIV(TCLK_PMU_WDT, "tclk_pmu_wdt", mux_24m_32k_p, 0,
+			RV1106_PMUCLKSEL_CON(7), 2, 1, MFLAGS,
+			RV1106_PMUCLKGATE_CON(2), 9, GFLAGS),
+
+	/* PD_SUBDDR */
+	COMPOSITE(CLK_CORE_DDRC_SRC, "clk_core_ddrc_src", mux_dpll_300m_p, CLK_IGNORE_UNUSED,
+			RV1106_SUBDDRCLKSEL_CON(0), 5, 1, MFLAGS, 0, 5, DFLAGS,
+			RV1106_SUBDDRCLKGATE_CON(0), 2, GFLAGS),
+	GATE(CLK_DFICTRL, "clk_dfictrl", "clk_core_ddrc_src", CLK_IGNORE_UNUSED,
+			RV1106_SUBDDRCLKGATE_CON(0), 5, GFLAGS),
+	GATE(CLK_DDRMON, "clk_ddrmon", "clk_core_ddrc_src", CLK_IGNORE_UNUSED,
+			RV1106_SUBDDRCLKGATE_CON(0), 4, GFLAGS),
+	GATE(CLK_DDR_PHY, "clk_ddr_phy", "clk_core_ddrc_src", CLK_IGNORE_UNUSED,
+			RV1106_SUBDDRCLKGATE_CON(0), 6, GFLAGS),
+	GATE(ACLK_DDRC, "aclk_ddrc", "clk_core_ddrc_src", CLK_IS_CRITICAL,
+			RV1106_SUBDDRCLKGATE_CON(0), 1, GFLAGS),
+	GATE(CLK_CORE_DDRC, "clk_core_ddrc", "clk_core_ddrc_src", CLK_IS_CRITICAL,
+			RV1106_SUBDDRCLKGATE_CON(0), 3, GFLAGS),
+
+
+	/* PD_VEPU */
+	COMPOSITE_NODIV(HCLK_VEPU_ROOT, "hclk_vepu_root", mux_200m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VEPUCLKSEL_CON(0), 0, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(0), 0, GFLAGS),
+	COMPOSITE_NODIV(ACLK_VEPU_COM_ROOT, "aclk_vepu_com_root", mux_400m_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VEPUCLKSEL_CON(0), 2, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE_NODIV(ACLK_VEPU_ROOT, "aclk_vepu_root", mux_300m_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VEPUCLKSEL_CON(0), 4, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(0), 2, GFLAGS),
+	COMPOSITE_NODIV(PCLK_VEPU_ROOT, "pclk_vepu_root", mux_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VEPUCLKSEL_CON(0), 6, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(0), 3, GFLAGS),
+	GATE(PCLK_SPI0, "pclk_spi0", "pclk_vepu_root", 0,
+			RV1106_VEPUCLKGATE_CON(1), 2, GFLAGS),
+	COMPOSITE_NODIV(CLK_SPI0, "clk_spi0", mux_200m_100m_50m_24m_p, 0,
+			RV1106_VEPUCLKSEL_CON(0), 12, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(1), 3, GFLAGS),
+	GATE(CLK_UART_DETN_FLT, "clk_uart_detn_flt", "xin24m", 0,
+			RV1106_VEPUCLKGATE_CON(1), 8, GFLAGS),
+	GATE(HCLK_VEPU, "hclk_vepu", "hclk_vepu_root", 0,
+			RV1106_VEPUCLKGATE_CON(0), 8, GFLAGS),
+	GATE(ACLK_VEPU, "aclk_vepu", "aclk_vepu_root", 0,
+			RV1106_VEPUCLKGATE_CON(0), 9, GFLAGS),
+	COMPOSITE_NODIV(CLK_CORE_VEPU, "clk_core_vepu", mux_400m_300m_pvtpll0_pvtpll1_p, 0,
+			RV1106_VEPUCLKSEL_CON(0), 8, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(0), 10, GFLAGS),
+	COMPOSITE_NODIV(CLK_CORE_VEPU_DVBM, "clk_core_vepu_dvbm", mux_200m_100m_50m_24m_p, 0,
+			RV1106_VEPUCLKSEL_CON(0), 10, 2, MFLAGS,
+			RV1106_VEPUCLKGATE_CON(0), 13, GFLAGS),
+	GATE(PCLK_GPIO1, "pclk_gpio1", "pclk_vepu_root", 0,
+			RV1106_VEPUCLKGATE_CON(0), 15, GFLAGS),
+	GATE(DBCLK_GPIO1, "dbclk_gpio1", "xin24m", 0,
+			RV1106_VEPUCLKGATE_CON(1), 0, GFLAGS),
+	GATE(HCLK_VEPU_PP, "hclk_vepu_pp", "hclk_vepu_root", 0,
+			RV1106_VEPUCLKGATE_CON(0), 11, GFLAGS),
+	GATE(ACLK_VEPU_PP, "aclk_vepu_pp", "aclk_vepu_root", 0,
+			RV1106_VEPUCLKGATE_CON(0), 12, GFLAGS),
+
+	/* PD_VI */
+	COMPOSITE_NODIV(HCLK_VI_ROOT, "hclk_vi_root", mux_150m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VICLKSEL_CON(0), 0, 2, MFLAGS,
+			RV1106_VICLKGATE_CON(0), 0, GFLAGS),
+	COMPOSITE_NODIV(ACLK_VI_ROOT, "aclk_vi_root", mux_339m_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VICLKSEL_CON(0), 2, 2, MFLAGS,
+			RV1106_VICLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE_NODIV(PCLK_VI_ROOT, "pclk_vi_root", mux_150m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VICLKSEL_CON(0), 4, 2, MFLAGS,
+			RV1106_VICLKGATE_CON(0), 2, GFLAGS),
+	COMPOSITE_NODIV(PCLK_VI_RTC_ROOT, "pclk_vi_rtc_root", mux_50m_24m_p, 0,
+			RV1106_VICLKSEL_CON(0), 6, 1, MFLAGS,
+			RV1106_VICLKGATE_CON(0), 3, GFLAGS),
+
+	GATE(PCLK_CSIHOST0, "pclk_csihost0", "pclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(1), 3, GFLAGS),
+	GATE(PCLK_CSIHOST1, "pclk_csihost1", "pclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(1), 5, GFLAGS),
+	GATE(PCLK_GPIO3, "pclk_gpio3", "pclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(1), 15, GFLAGS),
+	GATE(DBCLK_GPIO3, "dbclk_gpio3", "xin24m", 0,
+			RV1106_VICLKGATE_CON(2), 0, GFLAGS),
+	GATE(HCLK_ISP3P2, "hclk_isp3p2", "hclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(0), 7, GFLAGS),
+	GATE(ACLK_ISP3P2, "aclk_isp3p2", "aclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(0), 8, GFLAGS),
+	COMPOSITE_NODIV(CLK_CORE_ISP3P2, "clk_core_isp3p2", mux_339m_200m_pvtpll0_pvtpll1_p, 0,
+			RV1106_VICLKSEL_CON(0), 7, 2, MFLAGS,
+			RV1106_VICLKGATE_CON(0), 9, GFLAGS),
+	GATE(PCLK_MIPICSIPHY, "pclk_mipicsiphy", "pclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(1), 14, GFLAGS),
+	COMPOSITE(CCLK_SRC_SDMMC, "cclk_src_sdmmc", mux_400m_24m_p, 0,
+			RV1106_VICLKSEL_CON(1), 14, 1, MFLAGS, 8, 6, DFLAGS,
+			RV1106_VICLKGATE_CON(1), 11, GFLAGS),
+	GATE(HCLK_SDMMC, "hclk_sdmmc", "hclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(1), 12, GFLAGS),
+	GATE(CLK_SDMMC_DETN_FLT, "clk_sdmmc_detn_flt", "xin24m", 0,
+			RV1106_VICLKGATE_CON(1), 13, GFLAGS),
+	GATE(PCLK_VI_RTC_TEST, "pclk_vi_rtc_test", "pclk_vi_rtc_root", 0,
+			RV1106_VICLKGATE_CON(2), 5, GFLAGS),
+	GATE(PCLK_VI_RTC_PHY, "pclk_vi_rtc_phy", "pclk_vi_rtc_root", 0,
+			RV1106_VICLKGATE_CON(2), 6, GFLAGS),
+	COMPOSITE_NODIV(DCLK_VICAP, "dclk_vicap", mux_339m_200m_100m_24m_p, 0,
+			RV1106_VICLKSEL_CON(0), 9, 2, MFLAGS,
+			RV1106_VICLKGATE_CON(0), 10, GFLAGS),
+	GATE(ACLK_VICAP, "aclk_vicap", "aclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(0), 12, GFLAGS),
+	GATE(HCLK_VICAP, "hclk_vicap", "hclk_vi_root", 0,
+			RV1106_VICLKGATE_CON(0), 13, GFLAGS),
+
+	/* PD_VO */
+	COMPOSITE_NODIV(ACLK_MAC_ROOT, "aclk_mac_root", mux_300m_200m_100m_24m_p, 0,
+			RV1106_VOCLKSEL_CON(1), 12, 2, MFLAGS,
+			RV1106_VOCLKGATE_CON(1), 4, GFLAGS),
+	COMPOSITE_NODIV(ACLK_VO_ROOT, "aclk_vo_root", mux_400m_200m_100m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VOCLKSEL_CON(0), 0, 2, MFLAGS,
+			RV1106_VOCLKGATE_CON(0), 0, GFLAGS),
+	COMPOSITE_NODIV(HCLK_VO_ROOT, "hclk_vo_root", mux_200m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VOCLKSEL_CON(0), 2, 2, MFLAGS,
+			RV1106_VOCLKGATE_CON(0), 1, GFLAGS),
+	COMPOSITE_NODIV(PCLK_VO_ROOT, "pclk_vo_root", mux_150m_100m_50m_24m_p, CLK_IS_CRITICAL,
+			RV1106_VOCLKSEL_CON(0), 4, 2, MFLAGS,
+			RV1106_VOCLKGATE_CON(0), 2, GFLAGS),
+	COMPOSITE_NODIV(ACLK_VOP_ROOT, "aclk_vop_root", mux_300m_200m_100m_24m_p, 0,
+			RV1106_VOCLKSEL_CON(1), 10, 2, MFLAGS,
+			RV1106_VOCLKGATE_CON(0), 11, GFLAGS),
+
+	GATE(PCLK_GPIO2, "pclk_gpio2", "pclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(3), 0, GFLAGS),
+	GATE(DBCLK_GPIO2, "dbclk_gpio2", "xin24m", 0,
+			RV1106_VOCLKGATE_CON(3), 1, GFLAGS),
+	GATE(ACLK_MAC, "aclk_mac", "aclk_mac_root", 0,
+			RV1106_VOCLKGATE_CON(1), 8, GFLAGS),
+	GATE(PCLK_MAC, "pclk_mac", "pclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(1), 9, GFLAGS),
+	FACTOR(CLK_GMAC0_50M_O, "clk_gmac0_50m_o", "clk_50m_src", 0, 1, 1),
+	FACTOR(CLK_GMAC0_REF_50M, "clk_gmac0_ref_50m", "clk_gmac0_50m_o", 0, 1, 1),
+	DIV(CLK_GMAC0_TX_50M_O, "clk_gmac0_tx_50m_o", "clk_gmac0_50m_o", 0,
+			RV1106_VOCLKSEL_CON(2), 1, 6, DFLAGS),
+	GATE(CLK_MACPHY, "clk_macphy", "xin24m", 0,
+			RV1106_VOCLKGATE_CON(2), 13, GFLAGS),
+	GATE(CLK_OTPC_ARB, "clk_otpc_arb", "xin24m", 0,
+			RV1106_VOCLKGATE_CON(2), 11, GFLAGS),
+	GATE(PCLK_OTPC_NS, "pclk_otpc_ns", "pclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(2), 3, GFLAGS),
+	GATE(CLK_SBPI_OTPC_NS, "clk_sbpi_otpc_ns", "xin24m", 0,
+			RV1106_VOCLKGATE_CON(2), 5, GFLAGS),
+	COMPOSITE_NOMUX(CLK_USER_OTPC_NS, "clk_user_otpc_ns", "xin24m", 0,
+			RV1106_VOCLKSEL_CON(3), 10, 3, DFLAGS,
+			RV1106_VOCLKGATE_CON(2), 6, GFLAGS),
+	GATE(PCLK_OTPC_S, "pclk_otpc_s", "pclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(2), 7, GFLAGS),
+	GATE(CLK_SBPI_OTPC_S, "clk_sbpi_otpc_s", "xin24m", 0,
+			RV1106_VOCLKGATE_CON(2), 9, GFLAGS),
+	COMPOSITE_NOMUX(CLK_USER_OTPC_S, "clk_user_otpc_s", "xin24m", 0,
+			RV1106_VOCLKSEL_CON(3), 13, 3, DFLAGS,
+			RV1106_VOCLKGATE_CON(2), 10, GFLAGS),
+	GATE(PCLK_OTP_MASK, "pclk_otp_mask", "pclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(2), 14, GFLAGS),
+	GATE(CLK_PMC_OTP, "clk_pmc_otp", "clk_sbpi_otpc_s", 0,
+			RV1106_VOCLKGATE_CON(2), 15, GFLAGS),
+	GATE(HCLK_RGA2E, "hclk_rga2e", "hclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(0), 7, GFLAGS),
+	GATE(ACLK_RGA2E, "aclk_rga2e", "aclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(0), 8, GFLAGS),
+	COMPOSITE_NODIV(CLK_CORE_RGA2E, "clk_core_rga2e", mux_400m_200m_100m_24m_p, 0,
+			RV1106_VOCLKSEL_CON(1), 8, 2, MFLAGS,
+			RV1106_VOCLKGATE_CON(0), 9, GFLAGS),
+	COMPOSITE(CCLK_SRC_SDIO, "cclk_src_sdio", mux_400m_24m_p, 0,
+			RV1106_VOCLKSEL_CON(2), 13, 1, MFLAGS, 7, 6, DFLAGS,
+			RV1106_VOCLKGATE_CON(1), 14, GFLAGS),
+	GATE(HCLK_SDIO, "hclk_sdio", "hclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(1), 15, GFLAGS),
+	GATE(PCLK_TSADC, "pclk_tsadc", "pclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(2), 0, GFLAGS),
+	COMPOSITE_NOMUX(CLK_TSADC, "clk_tsadc", "xin24m", 0,
+			RV1106_VOCLKSEL_CON(3), 0, 5, DFLAGS,
+			RV1106_VOCLKGATE_CON(2), 1, GFLAGS),
+	COMPOSITE_NOMUX(CLK_TSADC_TSEN, "clk_tsadc_tsen", "xin24m", 0,
+			RV1106_VOCLKSEL_CON(3), 5, 5, DFLAGS,
+			RV1106_VOCLKGATE_CON(2), 2, GFLAGS),
+	GATE(HCLK_VOP, "hclk_vop", "hclk_vo_root", 0,
+			RV1106_VOCLKGATE_CON(0), 13, GFLAGS),
+	GATE(DCLK_VOP, "dclk_vop", "dclk_vop_src", 0,
+			RV1106_VOCLKGATE_CON(0), 14, GFLAGS),
+	GATE(ACLK_VOP, "aclk_vop", "aclk_vop_root", 0,
+			RV1106_VOCLKGATE_CON(0), 15, GFLAGS),
+
+	/* IO CLK */
+	GATE(RX0PCLK_VICAP, "rx0pclk_vicap", "rx0pclk_vicap_io", 0,
+			RV1106_VICLKGATE_CON(1), 0, GFLAGS),
+	GATE(RX1PCLK_VICAP, "rx1pclk_vicap", "rx1pclk_vicap_io", 0,
+			RV1106_VICLKGATE_CON(1), 1, GFLAGS),
+	GATE(ISP0CLK_VICAP, "isp0clk_vicap", "isp0clk_vicap_io", 0,
+			RV1106_VICLKGATE_CON(1), 2, GFLAGS),
+	GATE(I0CLK_VICAP, "i0clk_vicap", "i0clk_vicap_io", 0,
+			RV1106_VICLKGATE_CON(0), 14, GFLAGS),
+	GATE(I1CLK_VICAP, "i1clk_vicap", "i1clk_vicap_io", 0,
+			RV1106_VICLKGATE_CON(0), 15, GFLAGS),
+	GATE(PCLK_VICAP, "pclk_vicap", "pclk_vicap_io", 0,
+			RV1106_VICLKGATE_CON(0), 11, GFLAGS),
+	GATE(CLK_RXBYTECLKHS_0, "clk_rxbyteclkhs_0", "clk_rxbyteclkhs_0_io", 0,
+			RV1106_VICLKGATE_CON(1), 4, GFLAGS),
+	GATE(CLK_RXBYTECLKHS_1, "clk_rxbyteclkhs_1", "clk_rxbyteclkhs_1_io", 0,
+			RV1106_VICLKGATE_CON(1), 6, GFLAGS),
+
+	GATE(PCLK_VICAP_VEPU, "pclk_vicap_vepu", "pclk_vicap_vepu_io", 0,
+			RV1106_VEPUCLKGATE_CON(0), 14, GFLAGS),
+	GATE(SCLK_IN_SPI0, "sclk_in_spi0", "sclk_in_spi0_io", 0,
+			RV1106_VEPUCLKGATE_CON(1), 4, GFLAGS),
+
+	GATE(CLK_UTMI_USBOTG, "clk_utmi_usbotg", "clk_utmi_usbotg_io", 0,
+			RV1106_PERICLKGATE_CON(4), 9, GFLAGS),
+
+};
+
+static struct rockchip_clk_branch rv1106_grf_clk_branches[] __initdata = {
+	MMC(SCLK_EMMC_DRV, "emmc_drv", "cclk_src_emmc", RV1106_EMMC_CON0, 1),
+	MMC(SCLK_EMMC_SAMPLE, "emmc_sample", "cclk_src_emmc", RV1106_EMMC_CON1, 1),
+	MMC(SCLK_SDMMC_DRV,     "sdmmc_drv",    "cclk_src_sdmmc", RV1106_SDMMC_CON0, 1),
+	MMC(SCLK_SDMMC_SAMPLE,  "sdmmc_sample", "cclk_src_sdmmc", RV1106_SDMMC_CON1, 1),
+	MMC(SCLK_SDIO_DRV, "sdio_drv", "cclk_src_sdio", RV1106_SDIO_CON0, 1),
+	MMC(SCLK_SDIO_SAMPLE, "sdio_sample", "cclk_src_sdio", RV1106_SDIO_CON1, 1),
+};
+
+static void __iomem *rv1106_cru_base;
+static struct rockchip_clk_provider *grf_ctx, *cru_ctx;
+
+static void _cru_pvtpll_calibrate(int count_offset, int length_offset, int target_rate)
+{
+	unsigned int rate0, rate1, delta, length_ori, length, step, val, i = 0;
+
+	rate0 = readl_relaxed(rv1106_cru_base + count_offset);
+	if (rate0 < target_rate)
+		return;
+	/* delta < (3.125% * target_rate) */
+	if ((rate0 - target_rate) < (target_rate >> 5))
+		return;
+
+	length_ori = readl_relaxed(rv1106_cru_base + length_offset) & PVTPLL_LENGTH_SEL_MASK;
+	length = length_ori;
+	length++;
+	val = HIWORD_UPDATE(length, PVTPLL_LENGTH_SEL_MASK, PVTPLL_LENGTH_SEL_SHIFT);
+	writel_relaxed(val, rv1106_cru_base + length_offset);
+	usleep_range(2000, 2100);
+	rate1 = readl_relaxed(rv1106_cru_base + count_offset);
+	if (rate1 < target_rate)
+		return;
+	if (abs(rate1 - target_rate) < (target_rate >> 5))
+		return;
+
+	if (rate1 < rate0)
+		step = rate0 - rate1;
+	else
+		step = 5;
+	step = max_t(unsigned int, step, 5);
+	delta = rate1 - target_rate;
+	length += delta / step;
+	val = HIWORD_UPDATE(length, PVTPLL_LENGTH_SEL_MASK, PVTPLL_LENGTH_SEL_SHIFT);
+	writel_relaxed(val, rv1106_cru_base + length_offset);
+	usleep_range(2000, 2100);
+	rate0 = readl_relaxed(rv1106_cru_base + count_offset);
+
+	while (abs(rate0 - target_rate) >= (target_rate >> 5)) {
+		if (i++ > 20)
+			break;
+		if (rate0 > target_rate)
+			length++;
+		else
+			length--;
+		if (length <= length_ori)
+			break;
+		val = HIWORD_UPDATE(length, PVTPLL_LENGTH_SEL_MASK, PVTPLL_LENGTH_SEL_SHIFT);
+		writel_relaxed(val, rv1106_cru_base + length_offset);
+		usleep_range(2000, 2100);
+		rate0 = readl_relaxed(rv1106_cru_base + count_offset);
+	}
+}
+
+static void _grf_pvtpll_calibrate(int count_offset, int length_offset, int target_rate)
+{
+	unsigned int rate0, rate1, delta, length_ori, length, step, val, i = 0;
+
+	regmap_read(cru_ctx->grf, count_offset, &rate0);
+	if (rate0 < target_rate)
+		return;
+	/* delta < (3.125% * target_rate) */
+	if ((rate0 - target_rate) < (target_rate >> 5))
+		return;
+
+	regmap_read(cru_ctx->grf, length_offset, &length_ori);
+	length = length_ori;
+	length_ori = length;
+	length &= PVTPLL_LENGTH_SEL_MASK;
+	length++;
+	val = HIWORD_UPDATE(length, PVTPLL_LENGTH_SEL_MASK, PVTPLL_LENGTH_SEL_SHIFT);
+	regmap_write(cru_ctx->grf, length_offset, val);
+	usleep_range(2000, 2100);
+	regmap_read(cru_ctx->grf, count_offset, &rate1);
+	if ((rate1 < target_rate) || (rate1 >= rate0))
+		return;
+	if (abs(rate1 - target_rate) < (target_rate >> 5))
+		return;
+
+	step = rate0 - rate1;
+	delta = rate1 - target_rate;
+	length += delta / step;
+	val = HIWORD_UPDATE(length, PVTPLL_LENGTH_SEL_MASK, PVTPLL_LENGTH_SEL_SHIFT);
+	regmap_write(cru_ctx->grf, length_offset, val);
+	usleep_range(2000, 2100);
+	regmap_read(cru_ctx->grf, count_offset, &rate0);
+
+	while (abs(rate0 - target_rate) >= (target_rate >> 5)) {
+		if (i++ > 20)
+			break;
+		if (rate0 > target_rate)
+			length++;
+		else
+			length--;
+		if (length <= length_ori)
+			break;
+		val = HIWORD_UPDATE(length, PVTPLL_LENGTH_SEL_MASK, PVTPLL_LENGTH_SEL_SHIFT);
+		regmap_write(cru_ctx->grf, length_offset, val);
+		usleep_range(2000, 2100);
+		regmap_read(cru_ctx->grf, count_offset, &rate0);
+	}
+}
+
+static void rockchip_rv1106_pvtpll_calibrate(struct work_struct *w)
+{
+	struct clk *clk;
+	unsigned long rate;
+
+	clk = __clk_lookup("clk_pvtpll_0");
+	if (clk) {
+		rate = clk_get_rate(clk);
+		_cru_pvtpll_calibrate(CRU_PVTPLL0_OSC_CNT_AVG,
+				      CRU_PVTPLL0_CON0_H, rate / 1000000);
+	}
+
+	clk = __clk_lookup("clk_pvtpll_1");
+	if (clk) {
+		rate = clk_get_rate(clk);
+		_cru_pvtpll_calibrate(CRU_PVTPLL1_OSC_CNT_AVG,
+				      CRU_PVTPLL1_CON0_H, rate / 1000000);
+	}
+
+	clk = __clk_lookup("cpu_pvtpll");
+	if (clk) {
+		rate = clk_get_rate(clk);
+		_grf_pvtpll_calibrate(CPU_PVTPLL_OSC_CNT_AVG,
+				      CPU_PVTPLL_CON0_H, rate / 1000000);
+	}
+}
+static DECLARE_DEFERRABLE_WORK(pvtpll_calibrate_work, rockchip_rv1106_pvtpll_calibrate);
+
+static void rockchip_rv1106_pvtpll_init(struct rockchip_clk_provider *ctx)
+{
+	/* set pvtpll ref clk mux */
+	writel_relaxed(CPU_PVTPLL_PATH_CORE, ctx->reg_base + CPU_CLK_PATH_BASE);
+
+	regmap_write(ctx->grf, CPU_PVTPLL_CON0_H, HIWORD_UPDATE(0x7, PVTPLL_LENGTH_SEL_MASK,
+		     PVTPLL_LENGTH_SEL_SHIFT));
+	regmap_write(ctx->grf, CPU_PVTPLL_CON0_L, HIWORD_UPDATE(0x1, PVTPLL_RING_SEL_MASK,
+		     PVTPLL_RING_SEL_SHIFT));
+	regmap_write(ctx->grf, CPU_PVTPLL_CON0_L, HIWORD_UPDATE(0x3, PVTPLL_EN_MASK,
+		     PVTPLL_EN_SHIFT));
+
+	writel_relaxed(0x007f0000, ctx->reg_base + CRU_PVTPLL0_CON0_H);
+	writel_relaxed(0xffff0018, ctx->reg_base + CRU_PVTPLL0_CON1_L);
+	writel_relaxed(0xffff0004, ctx->reg_base + CRU_PVTPLL0_CON2_H);
+	writel_relaxed(0x00030003, ctx->reg_base + CRU_PVTPLL0_CON0_L);
+
+	writel_relaxed(0x007f0000, ctx->reg_base + CRU_PVTPLL1_CON0_H);
+	writel_relaxed(0xffff0018, ctx->reg_base + CRU_PVTPLL1_CON1_L);
+	writel_relaxed(0xffff0004, ctx->reg_base + CRU_PVTPLL1_CON2_H);
+	writel_relaxed(0x00030003, ctx->reg_base + CRU_PVTPLL1_CON0_L);
+
+	queue_delayed_work(system_freezable_wq, &pvtpll_calibrate_work, msecs_to_jiffies(300));
+}
+
+static void __init rv1106_clk_init(struct device_node *np)
+{
+	struct rockchip_clk_provider *ctx;
+	void __iomem *reg_base;
+	struct clk **cru_clks;
+
+	reg_base = of_iomap(np, 0);
+	if (!reg_base) {
+		pr_err("%s: could not map cru region\n", __func__);
+		return;
+	}
+
+	rv1106_cru_base = reg_base;
+
+	ctx = rockchip_clk_init(np, reg_base, CLK_NR_CLKS);
+	if (IS_ERR(ctx)) {
+		pr_err("%s: rockchip clk init failed\n", __func__);
+		iounmap(reg_base);
+		return;
+	}
+	cru_ctx = ctx;
+
+	rockchip_rv1106_pvtpll_init(ctx);
+
+	cru_clks = ctx->clk_data.clks;
+
+	rockchip_clk_register_plls(ctx, rv1106_pll_clks,
+				   ARRAY_SIZE(rv1106_pll_clks),
+				   RV1106_GRF_SOC_STATUS0);
+
+	rockchip_clk_register_armclk(ctx, ARMCLK, "armclk",
+				     mux_armclk_p, ARRAY_SIZE(mux_armclk_p),
+				     &rv1106_cpuclk_data, rv1106_cpuclk_rates,
+				     ARRAY_SIZE(rv1106_cpuclk_rates));
+
+	rockchip_clk_register_branches(ctx, rv1106_clk_branches,
+				       ARRAY_SIZE(rv1106_clk_branches));
+
+	rockchip_clk_register_branches(grf_ctx, rv1106_grf_clk_branches,
+				       ARRAY_SIZE(rv1106_grf_clk_branches));
+
+	rockchip_register_softrst(np, 31745, reg_base + RV1106_PMUSOFTRST_CON(0),
+				  ROCKCHIP_SOFTRST_HIWORD_MASK);
+
+	rockchip_register_restart_notifier(ctx, RV1106_GLB_SRST_FST, NULL);
+
+	rockchip_clk_of_add_provider(np, ctx);
+}
+
+CLK_OF_DECLARE(rv1106_cru, "rockchip,rv1106-cru", rv1106_clk_init);
+
+static void __init rv1106_grf_clk_init(struct device_node *np)
+{
+	struct rockchip_clk_provider *ctx;
+	void __iomem *reg_base;
+
+	reg_base = of_iomap(of_get_parent(np), 0);
+	if (!reg_base) {
+		pr_err("%s: could not map cru grf region\n", __func__);
+		return;
+	}
+
+	ctx = rockchip_clk_init(np, reg_base, CLK_NR_GRF_CLKS);
+	if (IS_ERR(ctx)) {
+		pr_err("%s: rockchip grf clk init failed\n", __func__);
+		return;
+	}
+	grf_ctx = ctx;
+
+	rockchip_clk_of_add_provider(np, ctx);
+}
+CLK_OF_DECLARE(rv1106_grf_cru, "rockchip,rv1106-grf-cru", rv1106_grf_clk_init);
+
+#ifdef MODULE
+struct clk_rv1106_inits {
+	void (*inits)(struct device_node *np);
+};
+
+static const struct clk_rv1106_inits clk_rv1106_init = {
+	.inits = rv1106_clk_init,
+};
+
+static const struct clk_rv1106_inits clk_rv1106_grf_init = {
+	.inits = rv1106_grf_clk_init,
+};
+
+static const struct of_device_id clk_rv1106_match_table[] = {
+	{
+		.compatible = "rockchip,rv1106-cru",
+		.data = &clk_rv1106_init,
+	}, {
+		.compatible = "rockchip,rv1106-grf-cru",
+		.data = &clk_rv1106_grf_init,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, clk_rv1106_match_table);
+
+static int __init clk_rv1106_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *match;
+	const struct clk_rv1106_inits *init_data;
+
+	match = of_match_device(clk_rv1106_match_table, &pdev->dev);
+	if (!match || !match->data)
+		return -EINVAL;
+
+	init_data = match->data;
+	if (init_data->inits)
+		init_data->inits(np);
+
+	return 0;
+}
+
+static struct platform_driver clk_rv1106_driver = {
+	.driver		= {
+		.name	= "clk-rv1106",
+		.of_match_table = clk_rv1106_match_table,
+	},
+};
+builtin_platform_driver_probe(clk_rv1106_driver, clk_rv1106_probe);
+
+MODULE_DESCRIPTION("Rockchip RV1106 Clock Driver");
+MODULE_LICENSE("GPL");
+#endif /* MODULE */
diff --git a/drivers/clk/rockchip/clk.h b/drivers/clk/rockchip/clk.h
index fd3b476de..8e8f88e86 100644
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -65,6 +65,64 @@ struct clk;
 #define PX30_PMU_CLKGATE_CON(x)		((x) * 0x4 + 0x80)
 #define PX30_PMU_MODE			0x0020
 
+#define RV1106_TOPCRU_BASE		0x10000
+#define RV1106_PERICRU_BASE		0x12000
+#define RV1106_VICRU_BASE		0x14000
+#define RV1106_NPUCRU_BASE		0x16000
+#define RV1106_CORECRU_BASE		0x18000
+#define RV1106_VEPUCRU_BASE		0x1A000
+#define RV1106_VOCRU_BASE		0x1C000
+#define RV1106_DDRCRU_BASE		0x1E000
+#define RV1106_SUBDDRCRU_BASE		0x1F000
+
+#define RV1106_VI_GRF_BASE		0x50000
+#define RV1106_VO_GRF_BASE		0x60000
+
+#define RV1106_PMUCLKSEL_CON(x)		((x) * 0x4 + 0x300)
+#define RV1106_PMUCLKGATE_CON(x)	((x) * 0x4 + 0x800)
+#define RV1106_PMUSOFTRST_CON(x)	((x) * 0x4 + 0xa00)
+#define RV1106_PLL_CON(x)		((x) * 0x4 + RV1106_TOPCRU_BASE)
+#define RV1106_MODE_CON			(0x280 + RV1106_TOPCRU_BASE)
+#define RV1106_CLKSEL_CON(x)		((x) * 0x4 + 0x300 + RV1106_TOPCRU_BASE)
+#define RV1106_CLKGATE_CON(x)		((x) * 0x4 + 0x800 + RV1106_TOPCRU_BASE)
+#define RV1106_SOFTRST_CON(x)		((x) * 0x4 + 0xa00 + RV1106_TOPCRU_BASE)
+#define RV1106_GLB_SRST_FST		(0xc08 + RV1106_TOPCRU_BASE)
+#define RV1106_GLB_SRST_SND		(0xc0c + RV1106_TOPCRU_BASE)
+#define RV1106_SDIO_CON0		(0x1c + RV1106_VO_GRF_BASE)
+#define RV1106_SDIO_CON1		(0x20 + RV1106_VO_GRF_BASE)
+#define RV1106_SDMMC_CON0		(0x4 + RV1106_VI_GRF_BASE)
+#define RV1106_SDMMC_CON1		(0x8 + RV1106_VI_GRF_BASE)
+#define RV1106_EMMC_CON0		(0x20)
+#define RV1106_EMMC_CON1		(0x24)
+#define RV1106_PERICLKSEL_CON(x)	((x) * 0x4 + 0x300 + RV1106_PERICRU_BASE)
+#define RV1106_PERICLKGATE_CON(x)	((x) * 0x4 + 0x800 + RV1106_PERICRU_BASE)
+#define RV1106_PERISOFTRST_CON(x)	((x) * 0x4 + 0xa00 + RV1106_PERICRU_BASE)
+#define RV1106_VICLKSEL_CON(x)		((x) * 0x4 + 0x300 + RV1106_VICRU_BASE)
+#define RV1106_VICLKGATE_CON(x)		((x) * 0x4 + 0x800 + RV1106_VICRU_BASE)
+#define RV1106_VISOFTRST_CON(x)		((x) * 0x4 + 0xa00 + RV1106_VICRU_BASE)
+#define RV1106_VICLKSEL_CON(x)		((x) * 0x4 + 0x300 + RV1106_VICRU_BASE)
+#define RV1106_VICLKGATE_CON(x)		((x) * 0x4 + 0x800 + RV1106_VICRU_BASE)
+#define RV1106_VISOFTRST_CON(x)		((x) * 0x4 + 0xa00 + RV1106_VICRU_BASE)
+#define RV1106_NPUCLKSEL_CON(x)		((x) * 0x4 + 0x300 + RV1106_NPUCRU_BASE)
+#define RV1106_NPUCLKGATE_CON(x)	((x) * 0x4 + 0x800 + RV1106_NPUCRU_BASE)
+#define RV1106_NPUSOFTRST_CON(x)	((x) * 0x4 + 0xa00 + RV1106_NPUCRU_BASE)
+#define RV1106_CORECLKSEL_CON(x)	((x) * 0x4 + 0x300 + RV1106_CORECRU_BASE)
+#define RV1106_CORECLKGATE_CON(x)	((x) * 0x4 + 0x800 + RV1106_CORECRU_BASE)
+#define RV1106_CORESOFTRST_CON(x)	((x) * 0x4 + 0xa00 + RV1106_CORECRU_BASE)
+#define RV1106_VEPUCLKSEL_CON(x)	((x) * 0x4 + 0x300 + RV1106_VEPUCRU_BASE)
+#define RV1106_VEPUCLKGATE_CON(x)	((x) * 0x4 + 0x800 + RV1106_VEPUCRU_BASE)
+#define RV1106_VEPUSOFTRST_CON(x)	((x) * 0x4 + 0xa00 + RV1106_VEPUCRU_BASE)
+#define RV1106_VOCLKSEL_CON(x)		((x) * 0x4 + 0x300 + RV1106_VOCRU_BASE)
+#define RV1106_VOCLKGATE_CON(x)		((x) * 0x4 + 0x800 + RV1106_VOCRU_BASE)
+#define RV1106_VOSOFTRST_CON(x)		((x) * 0x4 + 0xa00 + RV1106_VOCRU_BASE)
+#define RV1106_DDRCLKSEL_CON(x)		((x) * 0x4 + 0x300 + RV1106_DDRCRU_BASE)
+#define RV1106_DDRCLKGATE_CON(x)	((x) * 0x4 + 0x800 + RV1106_DDRCRU_BASE)
+#define RV1106_DDRSOFTRST_CON(x)	((x) * 0x4 + 0xa00 + RV1106_DDRCRU_BASE)
+#define RV1106_SUBDDRCLKSEL_CON(x)	((x) * 0x4 + 0x300 + RV1106_SUBDDRCRU_BASE)
+#define RV1106_SUBDDRCLKGATE_CON(x)	((x) * 0x4 + 0x800 + RV1106_SUBDDRCRU_BASE)
+#define RV1106_SUBDDRSOFTRST_CON(x)	((x) * 0x4 + 0xa00 + RV1106_SUBDDRCRU_BASE)
+#define RV1106_SUBDDRMODE_CON		(0x280 + RV1106_SUBDDRCRU_BASE)
+
 #define RV1108_PLL_CON(x)		((x) * 0x4)
 #define RV1108_CLKSEL_CON(x)		((x) * 0x4 + 0x60)
 #define RV1108_CLKGATE_CON(x)		((x) * 0x4 + 0x120)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
index 7ae04d8d2..3449c1923 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -13,6 +13,7 @@
 #include <linux/phy.h>
 #include <linux/of_net.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
@@ -79,6 +80,9 @@ struct rk_priv_data {
 
 	struct regmap *grf;
 	struct regmap *php_grf;
+
+	unsigned char otp_data;
+	unsigned int bgs_increment;
 };
 
 #define HIWORD_UPDATE(val, mask, shift) \
@@ -91,6 +95,54 @@ struct rk_priv_data {
 	(((tx) ? soc##_GMAC_TXCLK_DLY_ENABLE : soc##_GMAC_TXCLK_DLY_DISABLE) | \
 	 ((rx) ? soc##_GMAC_RXCLK_DLY_ENABLE : soc##_GMAC_RXCLK_DLY_DISABLE))
 
+/* Integrated FEPHY */
+#define RK_FEPHY_SHUTDOWN		GRF_BIT(1)
+#define RK_FEPHY_POWERUP		GRF_CLR_BIT(1)
+#define RK_FEPHY_INTERNAL_RMII_SEL	GRF_BIT(6)
+#define RK_FEPHY_24M_CLK_SEL		(GRF_BIT(8) | GRF_BIT(9))
+#define RK_FEPHY_PHY_ID			GRF_BIT(11)
+
+#define RK_FEPHY_BGS			HIWORD_UPDATE(0x0, 0xf, 0)
+
+#define RK_FEPHY_BGS_MAX		7
+
+static void rk_gmac_integrated_fephy_powerup(struct rk_priv_data *priv,
+					     unsigned int ctrl_offset,
+					     unsigned int bgs_offset)
+{
+	struct device *dev = &priv->pdev->dev;
+
+	if (IS_ERR(priv->grf) || !priv->phy_reset) {
+		dev_err(dev, "%s: Missing rockchip,grf or phy_reset property\n",
+			__func__);
+		return;
+	}
+
+	unsigned int bgs = priv->otp_data;
+
+	reset_control_assert(priv->phy_reset);
+	udelay(20);
+	regmap_write(priv->grf, ctrl_offset,
+			RK_FEPHY_POWERUP |
+			RK_FEPHY_INTERNAL_RMII_SEL |
+			RK_FEPHY_24M_CLK_SEL |
+			RK_FEPHY_PHY_ID);
+
+	if (bgs > (RK_FEPHY_BGS_MAX - priv->bgs_increment) &&
+		bgs <= RK_FEPHY_BGS_MAX) {
+		bgs = HIWORD_UPDATE(RK_FEPHY_BGS_MAX, 0xf, 0);
+	} else {
+		bgs += priv->bgs_increment;
+		bgs &= 0xf;
+		bgs = HIWORD_UPDATE(bgs, 0xf, 0);
+	}
+
+	regmap_write(priv->grf, bgs_offset, bgs);
+	usleep_range(10 * 1000, 12 * 1000);
+	reset_control_deassert(priv->phy_reset);
+	usleep_range(50 * 1000, 60 * 1000);
+}
+
 #define PX30_GRF_GMAC_CON1		0x0904
 
 /* PX30_GRF_GMAC_CON1 */
@@ -1263,6 +1315,63 @@ static const struct rk_gmac_ops rk3588_ops = {
 	},
 };
 
+#define RV1106_VOGRF_GMAC_CLK_CON		0X60004
+
+#define RV1106_VOGRF_MACPHY_RMII_MODE		GRF_BIT(0)
+#define RV1106_VOGRF_GMAC_CLK_RMII_DIV2		GRF_BIT(2)
+#define RV1106_VOGRF_GMAC_CLK_RMII_DIV20	GRF_CLR_BIT(2)
+
+#define RV1106_VOGRF_MACPHY_CON0		0X60028
+#define RV1106_VOGRF_MACPHY_CON1		0X6002C
+
+static void rv1106_set_to_rmii(struct rk_priv_data *bsp_priv)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+
+	if (IS_ERR(bsp_priv->grf)) {
+		dev_err(dev, "%s: Missing rockchip,grf property\n", __func__);
+		return;
+	}
+
+	regmap_write(bsp_priv->grf, RV1106_VOGRF_GMAC_CLK_CON,
+		     RV1106_VOGRF_MACPHY_RMII_MODE |
+		     RV1106_VOGRF_GMAC_CLK_RMII_DIV2);
+}
+
+static void rv1106_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+	unsigned int val = 0;
+
+	if (IS_ERR(bsp_priv->grf)) {
+		dev_err(dev, "%s: Missing rockchip,grf property\n", __func__);
+		return;
+	}
+
+	if (speed == 10) {
+		val = RV1106_VOGRF_GMAC_CLK_RMII_DIV20;
+	} else if (speed == 100) {
+		val = RV1106_VOGRF_GMAC_CLK_RMII_DIV2;
+	} else {
+		dev_err(dev, "unknown speed value for RMII! speed=%d", speed);
+		return;
+	}
+
+	regmap_write(bsp_priv->grf, RV1106_VOGRF_GMAC_CLK_CON, val);
+}
+
+static void rv1106_integrated_sphy_powerup(struct rk_priv_data *priv)
+{
+	rk_gmac_integrated_fephy_powerup(priv, RV1106_VOGRF_MACPHY_CON0,
+				       RV1106_VOGRF_MACPHY_CON1);
+}
+
+static const struct rk_gmac_ops rv1106_ops = {
+	.set_to_rmii = rv1106_set_to_rmii,
+	.set_rmii_speed = rv1106_set_rmii_speed,
+	.integrated_phy_powerup = rv1106_integrated_sphy_powerup,
+};
+
 #define RV1108_GRF_GMAC_CON0		0X0900
 
 /* RV1108_GRF_GMAC_CON0 */
@@ -1682,11 +1791,46 @@ static struct rk_priv_data *rk_gmac_setup(struct platform_device *pdev,
 		bsp_priv->integrated_phy = of_property_read_bool(plat->phy_node,
 								 "phy-is-integrated");
 		if (bsp_priv->integrated_phy) {
+			unsigned char *efuse_buf;
+			struct nvmem_cell *cell;
+			size_t len;
+
 			bsp_priv->phy_reset = of_reset_control_get(plat->phy_node, NULL);
 			if (IS_ERR(bsp_priv->phy_reset)) {
 				dev_err(&pdev->dev, "No PHY reset control found.\n");
 				bsp_priv->phy_reset = NULL;
 			}
+
+			if (of_property_read_u32(plat->phy_node, "bgs,increment",
+						 &bsp_priv->bgs_increment)) {
+				bsp_priv->bgs_increment = 0;
+			} else {
+				if (bsp_priv->bgs_increment > RK_FEPHY_BGS_MAX) {
+					dev_err(dev, "%s: error bgs increment: %d\n",
+						__func__, bsp_priv->bgs_increment);
+					bsp_priv->bgs_increment = RK_FEPHY_BGS_MAX;
+				}
+			}
+
+			/* Read bgs from OTP if it exists */
+			cell = nvmem_cell_get(dev, "bgs");
+			if (IS_ERR(cell)) {
+				if (PTR_ERR(cell) != -EPROBE_DEFER)
+					dev_info(dev, "failed to get bgs cell: %ld, use default\n",
+						 PTR_ERR(cell));
+				else
+					return ERR_CAST(cell);
+			} else {
+				efuse_buf = nvmem_cell_read(cell, &len);
+				nvmem_cell_put(cell);
+				if (!IS_ERR(efuse_buf)) {
+					if (len == 1)
+						bsp_priv->otp_data = efuse_buf[0];
+					kfree(efuse_buf);
+				} else {
+					dev_err(dev, "failed to get efuse buf, use default\n");
+				}
+			}
 		}
 	}
 	dev_info(dev, "integrated PHY? (%s).\n",
@@ -1909,6 +2053,7 @@ static const struct of_device_id rk_gmac_dwmac_match[] = {
 	{ .compatible = "rockchip,rk3399-gmac", .data = &rk3399_ops },
 	{ .compatible = "rockchip,rk3568-gmac", .data = &rk3568_ops },
 	{ .compatible = "rockchip,rk3588-gmac", .data = &rk3588_ops },
+	{ .compatible = "rockchip,rv1106-gmac", .data = &rv1106_ops },
 	{ .compatible = "rockchip,rv1108-gmac", .data = &rv1108_ops },
 	{ .compatible = "rockchip,rv1126-gmac", .data = &rv1126_ops },
 	{ }
diff --git a/drivers/nvmem/rockchip-otp.c b/drivers/nvmem/rockchip-otp.c
index 7107d68a2..32e215aaf 100644
--- a/drivers/nvmem/rockchip-otp.c
+++ b/drivers/nvmem/rockchip-otp.c
@@ -184,6 +184,80 @@ static int px30_otp_read(void *context, unsigned int offset,
 	return ret;
 }
 
+static int rk3568_otp_read(void *context, unsigned int offset, void *val,
+			   size_t bytes)
+{
+	struct rockchip_otp *otp = context;
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	unsigned int otp_qp;
+	u32 out_value;
+	u8 *buf;
+	int ret = 0, i = 0;
+
+	addr_start = rounddown(offset, RK3568_NBYTES) / RK3568_NBYTES;
+	addr_end = roundup(offset + bytes, RK3568_NBYTES) / RK3568_NBYTES;
+	addr_offset = offset % RK3568_NBYTES;
+	addr_len = addr_end - addr_start;
+
+	buf = kzalloc(array3_size(addr_len, RK3568_NBYTES, sizeof(*buf)),
+		      GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = clk_bulk_prepare_enable(otp->num_clks, otp->clks);
+	if (ret < 0) {
+		dev_err(otp->dev, "failed to prepare/enable clks\n");
+		goto out;
+	}
+
+	ret = rockchip_otp_reset(otp);
+	if (ret) {
+		dev_err(otp->dev, "failed to reset otp phy\n");
+		goto disable_clks;
+	}
+
+	ret = px30_otp_ecc_enable(otp, true);
+	if (ret < 0) {
+		dev_err(otp->dev, "rockchip_otp_ecc_enable err\n");
+		goto disable_clks;
+	}
+
+	writel(OTPC_USE_USER | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);
+	udelay(5);
+	while (addr_len--) {
+		writel(addr_start++ | OTPC_USER_ADDR_MASK,
+		       otp->base + OTPC_USER_ADDR);
+		writel(OTPC_USER_FSM_ENABLE | OTPC_USER_FSM_ENABLE_MASK,
+		       otp->base + OTPC_USER_ENABLE);
+		ret = px30_otp_wait_status(otp, OTPC_USER_DONE);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during read setup\n");
+			goto read_end;
+		}
+		otp_qp = readl(otp->base + OTPC_USER_QP);
+		if (((otp_qp & 0xc0) == 0xc0) || (otp_qp & 0x20)) {
+			ret = -EIO;
+			dev_err(otp->dev, "ecc check error during read setup\n");
+			goto read_end;
+		}
+		out_value = readl(otp->base + OTPC_USER_Q);
+		memcpy(&buf[i], &out_value, RK3568_NBYTES);
+		i += RK3568_NBYTES;
+	}
+
+	memcpy(val, buf + addr_offset, bytes);
+
+read_end:
+	writel(0x0 | OTPC_USE_USER_MASK, otp->base + OTPC_USER_CTRL);
+disable_clks:
+	clk_bulk_disable_unprepare(otp->num_clks, otp->clks);
+out:
+	kfree(buf);
+
+	return ret;
+}
+
+
 static int rk3588_otp_read(void *context, unsigned int offset,
 			   void *val, size_t bytes)
 {
@@ -284,6 +358,17 @@ static const struct rockchip_data rk3588_data = {
 	.reg_read = rk3588_otp_read,
 };
 
+static const char * const rv1106_otp_clocks[] = {
+	"usr", "sbpi", "apb", "phy", "arb", "pmc",
+};
+
+static const struct rockchip_data rv1106_data = {
+	.size = 0x80,
+	.clocks = rv1106_otp_clocks,
+	.num_clks = ARRAY_SIZE(rv1106_otp_clocks),
+	.reg_read = rk3568_otp_read,
+};
+
 static const struct of_device_id rockchip_otp_match[] = {
 	{
 		.compatible = "rockchip,px30-otp",
@@ -297,6 +382,10 @@ static const struct of_device_id rockchip_otp_match[] = {
 		.compatible = "rockchip,rk3588-otp",
 		.data = &rk3588_data,
 	},
+	{
+		.compatible = "rockchip,rv1106-otp",
+		.data = (void *)&rv1106_data,
+	},
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, rockchip_otp_match);
diff --git a/drivers/pinctrl/pinctrl-rockchip.c b/drivers/pinctrl/pinctrl-rockchip.c
index 7b7b8601d..ad3f48b95 100644
--- a/drivers/pinctrl/pinctrl-rockchip.c
+++ b/drivers/pinctrl/pinctrl-rockchip.c
@@ -1398,6 +1398,166 @@ static int px30_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
 	return 0;
 }
 
+#define RV1106_DRV_BITS_PER_PIN		8
+#define RV1106_DRV_PINS_PER_REG		2
+#define RV1106_DRV_GPIO0_OFFSET		0x10
+#define RV1106_DRV_GPIO1_OFFSET		0x80
+#define RV1106_DRV_GPIO2_OFFSET		0x100C0
+#define RV1106_DRV_GPIO3_OFFSET		0x20100
+#define RV1106_DRV_GPIO4_OFFSET		0x30020
+
+static int rv1106_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	/* GPIO0_IOC is located in PMU */
+	switch (bank->bank_num) {
+	case 0:
+		*regmap = info->regmap_pmu;
+		*reg = RV1106_DRV_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*regmap = info->regmap_base;
+		*reg = RV1106_DRV_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RV1106_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1106_DRV_PINS_PER_REG;
+	*bit *= RV1106_DRV_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RV1106_PULL_BITS_PER_PIN		2
+#define RV1106_PULL_PINS_PER_REG		8
+#define RV1106_PULL_GPIO0_OFFSET		0x38
+#define RV1106_PULL_GPIO1_OFFSET		0x1C0
+#define RV1106_PULL_GPIO2_OFFSET		0x101D0
+#define RV1106_PULL_GPIO3_OFFSET		0x201E0
+#define RV1106_PULL_GPIO4_OFFSET		0x30070
+
+static int rv1106_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	/* GPIO0_IOC is located in PMU */
+	switch (bank->bank_num) {
+	case 0:
+		*regmap = info->regmap_pmu;
+		*reg = RV1106_PULL_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*regmap = info->regmap_base;
+		*reg = RV1106_PULL_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RV1106_PULL_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1106_PULL_PINS_PER_REG;
+	*bit *= RV1106_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RV1106_SMT_BITS_PER_PIN		1
+#define RV1106_SMT_PINS_PER_REG		8
+#define RV1106_SMT_GPIO0_OFFSET		0x40
+#define RV1106_SMT_GPIO1_OFFSET		0x280
+#define RV1106_SMT_GPIO2_OFFSET		0x10290
+#define RV1106_SMT_GPIO3_OFFSET		0x202A0
+#define RV1106_SMT_GPIO4_OFFSET		0x300A0
+
+static int rv1106_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	/* GPIO0_IOC is located in PMU */
+	switch (bank->bank_num) {
+	case 0:
+		*regmap = info->regmap_pmu;
+		*reg = RV1106_SMT_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*regmap = info->regmap_base;
+		*reg = RV1106_SMT_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RV1106_SMT_PINS_PER_REG) * 4);
+	*bit = pin_num % RV1106_SMT_PINS_PER_REG;
+	*bit *= RV1106_SMT_BITS_PER_PIN;
+
+	return 0;
+}
+
 #define RV1108_PULL_PMU_OFFSET		0x10
 #define RV1108_PULL_OFFSET		0x110
 #define RV1108_PULL_PINS_PER_REG	8
@@ -3526,6 +3686,48 @@ static struct rockchip_pin_ctrl px30_pin_ctrl = {
 		.schmitt_calc_reg	= px30_calc_schmitt_reg_and_bit,
 };
 
+static struct rockchip_pin_bank rv1106_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0",
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,
+			     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0, 0x08, 0x10, 0x18),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(2, 32, "gpio2",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x10020, 0x10028, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(3, 32, "gpio3",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20040, 0x20048, 0x20050, 0x20058),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(4, 24, "gpio4",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0,
+				    0x30000, 0x30008, 0x30010, 0),
+};
+
+static struct rockchip_pin_ctrl rv1106_pin_ctrl __maybe_unused = {
+	.pin_banks		= rv1106_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rv1106_pin_banks),
+	.label			= "RV1106-GPIO",
+	.type			= RV1106,
+	.pull_calc_reg		= rv1106_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rv1106_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rv1106_calc_schmitt_reg_and_bit,
+};
+
 static struct rockchip_pin_bank rv1108_pin_banks[] = {
 	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0", IOMUX_SOURCE_PMU,
 					     IOMUX_SOURCE_PMU,
@@ -3980,6 +4182,8 @@ static struct rockchip_pin_ctrl rk3588_pin_ctrl = {
 static const struct of_device_id rockchip_pinctrl_dt_match[] = {
 	{ .compatible = "rockchip,px30-pinctrl",
 		.data = &px30_pin_ctrl },
+	{ .compatible = "rockchip,rv1106-pinctrl",
+		.data = &rv1106_pin_ctrl },
 	{ .compatible = "rockchip,rv1108-pinctrl",
 		.data = &rv1108_pin_ctrl },
 	{ .compatible = "rockchip,rv1126-pinctrl",
diff --git a/drivers/pinctrl/pinctrl-rockchip.h b/drivers/pinctrl/pinctrl-rockchip.h
index 849266f8b..24474bbb0 100644
--- a/drivers/pinctrl/pinctrl-rockchip.h
+++ b/drivers/pinctrl/pinctrl-rockchip.h
@@ -185,6 +185,7 @@
 
 enum rockchip_pinctrl_type {
 	PX30,
+	RV1106,
 	RV1108,
 	RV1126,
 	RK2928,
diff --git a/include/dt-bindings/clock/rv1106-cru.h b/include/dt-bindings/clock/rv1106-cru.h
new file mode 100644
index 000000000..95d3652fa
--- /dev/null
+++ b/include/dt-bindings/clock/rv1106-cru.h
@@ -0,0 +1,571 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co. Ltd.
+ * Author: Elaine Zhang <zhangqing@rock-chips.com>
+ */
+
+#ifndef _DT_BINDINGS_CLK_ROCKCHIP_RV1106_H
+#define _DT_BINDINGS_CLK_ROCKCHIP_RV1106_H
+
+/* pll clocks */
+#define PLL_APLL		1
+#define PLL_DPLL		2
+#define PLL_CPLL		3
+#define PLL_GPLL		4
+#define ARMCLK			5
+
+/* clk (clocks) */
+#define PCLK_DDRPHY		11
+#define PCLK_DDR_ROOT		12
+#define PCLK_DDRMON		13
+#define CLK_TIMER_DDRMON	14
+#define PCLK_DDRC		15
+#define PCLK_DFICTRL		16
+#define ACLK_DDR_ROOT		17
+#define ACLK_SYS_SHRM		18
+#define HCLK_NPU_ROOT		19
+#define ACLK_NPU_ROOT		20
+#define PCLK_NPU_ROOT		21
+#define HCLK_RKNN		22
+#define ACLK_RKNN		23
+#define PCLK_ACODEC		24
+#define MCLK_ACODEC_TX		25
+#define CLK_CORE_CRYPTO		27
+#define CLK_PKA_CRYPTO		28
+#define ACLK_CRYPTO		29
+#define HCLK_CRYPTO		30
+#define ACLK_DECOM		31
+#define PCLK_DECOM		32
+#define DCLK_DECOM		33
+#define ACLK_DMAC		34
+#define PCLK_DSM		35
+#define MCLK_DSM		36
+#define CCLK_SRC_EMMC		37
+#define HCLK_EMMC		38
+#define PCLK_GPIO4		39
+#define DBCLK_GPIO4		40
+#define PCLK_I2C0		41
+#define CLK_I2C0		42
+#define PCLK_I2C2		43
+#define CLK_I2C2		44
+#define PCLK_I2C3		45
+#define CLK_I2C3		46
+#define PCLK_I2C4		47
+#define CLK_I2C4		48
+#define HCLK_I2S0		49
+#define PCLK_DFT2APB		50
+#define HCLK_IVE		51
+#define ACLK_IVE		52
+#define PCLK_PWM0_PERI		53
+#define CLK_PWM0_PERI		54
+#define CLK_CAPTURE_PWM0_PERI	55
+#define PCLK_PERI_ROOT		56
+#define ACLK_PERI_ROOT		57
+#define HCLK_PERI_ROOT		58
+#define CLK_TIMER_ROOT		59
+#define ACLK_BUS_ROOT		60
+#define HCLK_SFC		61
+#define SCLK_SFC		62
+#define PCLK_UART0		63
+#define CLK_PVTM_CORE		64
+#define PCLK_UART1		65
+#define CLK_CORE_MCU_RTC	66
+#define PCLK_PWM1_PERI		67
+#define CLK_PWM1_PERI		68
+#define CLK_CAPTURE_PWM1_PERI	69
+#define PCLK_PWM2_PERI		70
+#define CLK_PWM2_PERI		71
+#define CLK_CAPTURE_PWM2_PERI	72
+#define HCLK_BOOTROM		73
+#define HCLK_SAI		74
+#define MCLK_SAI		75
+#define PCLK_SARADC		76
+#define CLK_SARADC		77
+#define PCLK_SPI1		78
+#define CLK_SPI1		79
+#define PCLK_STIMER		80
+#define CLK_STIMER0		81
+#define CLK_STIMER1		82
+#define PCLK_TIMER		83
+#define CLK_TIMER0		84
+#define CLK_TIMER1		85
+#define CLK_TIMER2		86
+#define CLK_TIMER3		87
+#define CLK_TIMER4		88
+#define CLK_TIMER5		89
+#define HCLK_TRNG_NS		90
+#define HCLK_TRNG_S		91
+#define PCLK_UART2		92
+#define HCLK_CPU		93
+#define PCLK_UART3		94
+#define CLK_CORE_MCU		95
+#define PCLK_UART4		96
+#define PCLK_DDR_HWLP		97
+#define PCLK_UART5		98
+#define ACLK_USBOTG		100
+#define CLK_REF_USBOTG		101
+#define CLK_UTMI_USBOTG		102
+#define PCLK_USBPHY		103
+#define CLK_REF_USBPHY		104
+#define PCLK_WDT_NS		105
+#define TCLK_WDT_NS		106
+#define PCLK_WDT_S		107
+#define TCLK_WDT_S		108
+#define CLK_DDR_FAIL_SAFE	109
+#define XIN_OSC0_DIV		110
+#define CLK_DEEPSLOW		111
+#define PCLK_PMU_GPIO0		112
+#define DBCLK_PMU_GPIO0		113
+#define CLK_PMU			114
+#define PCLK_PMU		115
+#define PCLK_PMU_HP_TIMER	116
+#define CLK_PMU_HP_TIMER	117
+#define CLK_PMU_32K_HP_TIMER	118
+#define PCLK_I2C1		119
+#define CLK_I2C1		120
+#define PCLK_PMU_IOC		121
+#define PCLK_PMU_MAILBOX	122
+#define CLK_PMU_MCU		123
+#define CLK_PMU_MCU_RTC		124
+#define CLK_PMU_MCU_JTAG	125
+#define CLK_PVTM_PMU		126
+#define PCLK_PVTM_PMU		127
+#define CLK_REFOUT		128
+#define CLK_100M_PMU		129
+#define PCLK_PMU_ROOT		130
+#define HCLK_PMU_ROOT		131
+#define HCLK_PMU_SRAM		132
+#define PCLK_PMU_WDT		133
+#define TCLK_PMU_WDT		134
+#define CLK_DFICTRL		135
+#define CLK_DDRMON		136
+#define CLK_DDR_PHY		137
+#define ACLK_DDRC		138
+#define CLK_CORE_DDRC_SRC	139
+#define CLK_CORE_DDRC		140
+#define CLK_50M_SRC		141
+#define CLK_100M_SRC		142
+#define CLK_150M_SRC		143
+#define CLK_200M_SRC		144
+#define CLK_250M_SRC		145
+#define CLK_300M_SRC		146
+#define CLK_339M_SRC		147
+#define CLK_400M_SRC		148
+#define CLK_450M_SRC		149
+#define CLK_500M_SRC		150
+#define CLK_I2S0_8CH_TX_SRC	151
+#define CLK_I2S0_8CH_TX_FRAC	152
+#define CLK_I2S0_8CH_TX		153
+#define CLK_I2S0_8CH_RX_SRC	154
+#define CLK_I2S0_8CH_RX_FRAC	155
+#define CLK_I2S0_8CH_RX		156
+#define I2S0_8CH_MCLKOUT	157
+#define MCLK_I2S0_8CH_RX	158
+#define MCLK_I2S0_8CH_TX	159
+#define CLK_REF_MIPI0_SRC	160
+#define CLK_REF_MIPI0_FRAC	161
+#define CLK_REF_MIPI0_OUT	162
+#define CLK_REF_MIPI1_SRC	163
+#define CLK_REF_MIPI1_FRAC	164
+#define MCLK_REF_MIPI0		165
+#define MCLK_REF_MIPI1		166
+#define CLK_REF_MIPI0		167
+#define CLK_REF_MIPI1		168
+#define CLK_UART0_SRC		169
+#define CLK_UART0_FRAC		170
+#define CLK_UART0		171
+#define SCLK_UART0		172
+#define CLK_UART1_SRC		173
+#define CLK_UART1_FRAC		174
+#define CLK_UART1		175
+#define SCLK_UART1		176
+#define CLK_UART2_SRC		177
+#define CLK_UART2_FRAC		178
+#define CLK_UART2		179
+#define SCLK_UART2		180
+#define CLK_UART3_SRC		181
+#define CLK_UART3_FRAC		182
+#define CLK_UART3		183
+#define SCLK_UART3		184
+#define CLK_UART4_SRC		185
+#define CLK_UART4_FRAC		186
+#define CLK_UART4		187
+#define SCLK_UART4		188
+#define CLK_UART5_SRC		189
+#define CLK_UART5_FRAC		190
+#define CLK_UART5		191
+#define SCLK_UART5		192
+#define CLK_VICAP_M0_SRC	193
+#define CLK_VICAP_M0_FRAC	194
+#define CLK_VICAP_M0		195
+#define SCLK_VICAP_M0		196
+#define CLK_VICAP_M1_SRC	197
+#define CLK_VICAP_M1_FRAC	198
+#define CLK_VICAP_M1		199
+#define SCLK_VICAP_M1		200
+#define DCLK_VOP_SRC		201
+#define PCLK_CRU		202
+#define PCLK_TOP_ROOT		203
+#define PCLK_SPI0		204
+#define CLK_SPI0		205
+#define SCLK_IN_SPI0		206
+#define CLK_UART_DETN_FLT	207
+#define HCLK_VEPU		208
+#define ACLK_VEPU		209
+#define CLK_CORE_VEPU		210
+#define CLK_CORE_VEPU_DVBM	211
+#define PCLK_GPIO1		212
+#define DBCLK_GPIO1		213
+#define HCLK_VEPU_PP		214
+#define ACLK_VEPU_PP		215
+#define HCLK_VEPU_ROOT		216
+#define ACLK_VEPU_COM_ROOT	217
+#define ACLK_VEPU_ROOT		218
+#define PCLK_VEPU_ROOT		219
+#define PCLK_VICAP_VEPU		220
+#define PCLK_CSIHOST0		221
+#define CLK_RXBYTECLKHS_0	222
+#define PCLK_CSIHOST1		223
+#define CLK_RXBYTECLKHS_1	224
+#define PCLK_GPIO3		225
+#define DBCLK_GPIO3		226
+#define HCLK_ISP3P2		227
+#define ACLK_ISP3P2		228
+#define CLK_CORE_ISP3P2		229
+#define PCLK_MIPICSIPHY		230
+#define CCLK_SRC_SDMMC		231
+#define HCLK_SDMMC		232
+#define CLK_SDMMC_DETN_FLT	233
+#define HCLK_VI_ROOT		234
+#define ACLK_VI_ROOT		235
+#define PCLK_VI_ROOT		236
+#define PCLK_VI_RTC_ROOT	237
+#define PCLK_VI_RTC_TEST	238
+#define PCLK_VI_RTC_PHY		239
+#define DCLK_VICAP		240
+#define PCLK_VICAP		241
+#define ACLK_VICAP		242
+#define HCLK_VICAP		243
+#define I0CLK_VICAP		244
+#define I1CLK_VICAP		245
+#define RX0PCLK_VICAP		246
+#define RX1PCLK_VICAP		247
+#define ISP0CLK_VICAP		248
+#define PCLK_GPIO2		249
+#define DBCLK_GPIO2		250
+#define ACLK_MAC		251
+#define PCLK_MAC		252
+#define CLK_GMAC0_50M_O		253
+#define CLK_GMAC0_TX_50M_O	254
+#define CLK_GMAC0_REF_50M	255
+#define CLK_GMAC0_TX_50M	256
+#define CLK_GMAC0_RX_50M	257
+#define ACLK_MAC_ROOT		258
+#define CLK_MACPHY		259
+#define CLK_OTPC_ARB		260
+#define PCLK_OTPC_NS		261
+#define CLK_SBPI_OTPC_NS	262
+#define CLK_USER_OTPC_NS	263
+#define PCLK_OTPC_S		264
+#define CLK_SBPI_OTPC_S		265
+#define CLK_USER_OTPC_S		266
+#define PCLK_OTP_MASK		267
+#define CLK_PMC_OTP		268
+#define HCLK_RGA2E		269
+#define ACLK_RGA2E		270
+#define CLK_CORE_RGA2E		271
+#define CCLK_SRC_SDIO		272
+#define HCLK_SDIO		273
+#define PCLK_TSADC		274
+#define CLK_TSADC		275
+#define CLK_TSADC_TSEN		276
+#define ACLK_VO_ROOT		277
+#define HCLK_VO_ROOT		278
+#define PCLK_VO_ROOT		279
+#define ACLK_VOP_ROOT		280
+#define HCLK_VOP		281
+#define DCLK_VOP		282
+#define ACLK_VOP		283
+#define CLK_RTC_32K		284
+#define PCLK_MAILBOX		291
+
+#define CLK_NR_CLKS		(PCLK_MAILBOX + 1)
+
+#define SCLK_EMMC_DRV		1
+#define SCLK_EMMC_SAMPLE	2
+#define SCLK_SDMMC_DRV		3
+#define SCLK_SDMMC_SAMPLE	4
+#define SCLK_SDIO_DRV		5
+#define SCLK_SDIO_SAMPLE	6
+
+#define CLK_NR_GRF_CLKS		(SCLK_SDIO_SAMPLE + 1)
+
+/********Name=PMUSOFTRST_CON00,Offset=0xA00********/
+#define SRST_P_I2C1		3
+#define SRST_I2C1		4
+#define SRST_H_PMU_BIU		6
+#define SRST_P_PMU_BIU		7
+#define SRST_H_PMU_SRAM		8
+#define SRST_PMU_MCU		9
+#define SRST_PMU_MCU_PWRUP	10
+#define SRST_PMU_MCU_CPU	11
+#define SRST_T_PMU_MCU_CPU	12
+/********Name=PMUSOFTRST_CON01,Offset=0xA04********/
+#define SRST_P_PMU_GPIO0	18
+#define SRST_PMU_GPIO0		19
+#define SRST_PVTM_PMU		20
+#define SRST_P_PVTM_PMU		21
+#define SRST_DDR_FAIL_SAFE	31
+/********Name=PMUSOFTRST_CON02,Offset=0xA08********/
+#define SRST_P_PMU_HP_TIMER	32
+#define SRST_PMU_HP_TIMER	33
+#define SRST_PMU_32K_HP_TIMER	34
+#define SRST_P_PMU_IOC		35
+#define SRST_P_PMU_CRU		36
+#define SRST_P_PMU_GRF		37
+#define SRST_P_PMU_SGRF		38
+#define SRST_P_PMU_SGRF_REMAP	39
+#define SRST_P_PMU_WDT		40
+#define SRST_T_PMU_WDT		41
+#define SRST_P_PMU_MAILBOX	42
+#define SRST_WRITE_ENABLE	48
+/********Name=SOFTRST_CON02,Offset=0x10A08********/
+#define SRST_REF_PVTPLL_0	262183
+#define SRST_REF_PVTPLL_1	262184
+#define SRST_P_CRU		262186
+#define SRST_P_CRU_BIU		262187
+/********Name=PERISOFTRST_CON00,Offset=0x12A00********/
+#define SRST_P_PERI_BIU		294916
+#define SRST_A_PERI_BIU		294917
+#define SRST_H_PERI_BIU		294918
+#define SRST_H_BOOTROM		294919
+#define SRST_P_TIMER		294920
+#define SRST_TIMER0		294921
+#define SRST_TIMER1		294922
+#define SRST_TIMER2		294923
+#define SRST_TIMER3		294924
+#define SRST_TIMER4		294925
+#define SRST_TIMER5		294926
+#define SRST_P_STIMER		294927
+/********Name=PERISOFTRST_CON01,Offset=0x12A04********/
+#define SRST_STIMER0		294928
+#define SRST_STIMER1		294929
+#define SRST_P_WDT_NS		294930
+#define SRST_T_WDT_NS		294931
+#define SRST_P_WDT_S		294932
+#define SRST_T_WDT_S		294933
+#define SRST_P_I2C0		294934
+#define SRST_I2C0		294935
+#define SRST_P_I2C2		294938
+#define SRST_I2C2		294939
+#define SRST_P_I2C3		294940
+#define SRST_I2C3		294941
+#define SRST_P_I2C4		294942
+#define SRST_I2C4		294943
+/********Name=PERISOFTRST_CON02,Offset=0x12A08********/
+#define SRST_P_GPIO4		294944
+#define SRST_GPIO4		294945
+#define SRST_P_PERI_IOC		294946
+#define SRST_P_UART2		294947
+#define SRST_S_UART2		294950
+#define SRST_P_UART3		294951
+#define SRST_S_UART3		294954
+#define SRST_P_UART4		294955
+#define SRST_S_UART4		294958
+#define SRST_P_UART5		294959
+/********Name=PERISOFTRST_CON03,Offset=0x12A0C********/
+#define SRST_S_UART5		294962
+#define SRST_P_SARADC		294963
+#define SRST_SARADC		294964
+#define SRST_SARADC_PHY		294965
+#define SRST_P_SPI1		294966
+#define SRST_SPI1		294967
+#define SRST_H_TRNG_NS		294969
+#define SRST_H_TRNG_S		294970
+#define SRST_CORE_CRYPTO	294971
+#define SRST_PKA_CRYPTO		294972
+#define SRST_A_CRYPTO		294973
+#define SRST_H_CRYPTO		294974
+#define SRST_P_PWM1_PERI	294975
+/********Name=PERISOFTRST_CON04,Offset=0x12A10********/
+#define SRST_PWM1_PERI		294976
+#define SRST_P_PWM2_PERI	294978
+#define SRST_PWM2_PERI		294979
+#define SRST_P_PERI_GRF		294981
+#define SRST_P_PERI_CRU		294982
+#define SRST_A_USBOTG		294983
+#define SRST_A_BUS_BIU		294986
+#define SRST_H_EMMC		294989
+#define SRST_H_SFC		294990
+/********Name=PERISOFTRST_CON05,Offset=0x12A14********/
+#define SRST_S_SFC		294992
+#define SRST_P_USBPHY		294993
+#define SRST_USBPHY_POR		294994
+#define SRST_USBPHY_OTG		294995
+#define SRST_A_DMAC		295000
+#define SRST_A_DECOM		295001
+#define SRST_P_DECOM		295002
+#define SRST_D_DECOM		295003
+#define SRST_P_PERI_SGRF	295004
+#define SRST_H_SAI		295005
+#define SRST_M_SAI		295006
+#define SRST_M_I2S0_8CH_TX	295007
+/********Name=PERISOFTRST_CON06,Offset=0x12A18********/
+#define SRST_H_I2S0		295008
+#define SRST_M_DSM		295009
+#define SRST_P_DSM		295010
+#define SRST_P_ACODEC		295011
+#define SRST_M_I2S0_8CH_RX	295014
+#define SRST_P_DFT2APB		295015
+#define SRST_H_IVE		295017
+#define SRST_A_IVE		295018
+#define SRST_P_UART0		295019
+#define SRST_S_UART0		295022
+#define SRST_P_UART1		295023
+/********Name=PERISOFTRST_CON07,Offset=0x12A1C********/
+#define SRST_S_UART1		295026
+#define SRST_P_PWM0_PERI	295027
+#define SRST_PWM0_PERI		295028
+/********Name=VISOFTRST_CON00,Offset=0x14A00********/
+#define SRST_H_VI_BIU		327684
+#define SRST_A_VI_BIU		327685
+#define SRST_P_VI_BIU		327686
+#define SRST_CORE_ISP3P2	327689
+#define SRST_D_VICAP		327690
+#define SRST_P_VICAP		327691
+#define SRST_A_VICAP		327692
+#define SRST_H_VICAP		327693
+#define SRST_VICAP_I0		327694
+#define SRST_VICAP_I1		327695
+/********Name=VISOFTRST_CON01,Offset=0x14A04********/
+#define SRST_VICAP_RX0		327696
+#define SRST_VICAP_RX1		327697
+#define SRST_VICAP_ISP0		327698
+#define SRST_P_CSIHOST0		327700
+#define SRST_P_CSIHOST1		327702
+#define SRST_H_SDMMC		327708
+#define SRST_SDMMC_DETN_FLT	327709
+#define SRST_P_MIPICSIPHY	327710
+#define SRST_P_GPIO3		327711
+/********Name=VISOFTRST_CON02,Offset=0x14A08********/
+#define SRST_GPIO3		327712
+#define SRST_P_VI_IOC		327713
+#define SRST_P_VI_GRF		327714
+#define SRST_P_VI_SGRF		327715
+#define SRST_P_VI_CRU		327716
+#define SRST_P_VI_RTC_TEST	327717
+#define SRST_P_VI_RTC_NIU	327719
+/********Name=NPUSOFTRST_CON00,Offset=0x16A00********/
+#define SRST_H_NPU_BIU		360451
+#define SRST_A_NPU_BIU		360452
+#define SRST_P_NPU_BIU		360453
+#define SRST_P_NPU_CRU		360454
+#define SRST_P_NPU_SGRF		360455
+#define SRST_P_NPU_GRF		360456
+#define SRST_H_RKNN		360457
+#define SRST_A_RKNN		360458
+/********Name=CORESOFTRST_CON00,Offset=0x18A00********/
+#define SRST_NCOREPORESET	393217
+#define SRST_NCORESET		393218
+#define SRST_NDBGRESET		393219
+#define SRST_NL2RESET		393220
+#define SRST_A_M_CORE_BIU	393221
+#define SRST_P_DBG		393222
+#define SRST_POT_DBG		393223
+#define SRST_NT_DBG		393224
+#define SRST_P_CORE_GRF		393227
+#define SRST_H_CPU_BIU		393228
+#define SRST_P_CPU_BIU		393229
+#define SRST_PVTM_CORE		393230
+#define SRST_P_PVTM_CORE	393231
+/********Name=CORESOFTRST_CON01,Offset=0x18A04********/
+#define SRST_REF_PVTPLL_CORE	393232
+#define SRST_CORE_MCU		393233
+#define SRST_CORE_MCU_PWRUP	393234
+#define SRST_CORE_MCU_CPU	393235
+#define SRST_T_CORE_MCU_CPU	393236
+#define SRST_MCU_BIU		393237
+#define SRST_P_MAILBOX		393240
+#define SRST_P_INTMUX		393241
+#define SRST_P_CORE_CRU		393242
+#define SRST_P_CORE_SGRF	393243
+#define SRST_H_CACHE		393244
+/********Name=VEPUSOFTRST_CON00,Offset=0x1AA00********/
+#define SRST_H_VEPU_BIU		425988
+#define SRST_A_VEPU_BIU		425989
+#define SRST_A_VEPU_COM_BIU	425990
+#define SRST_P_VEPU_BIU		425991
+#define SRST_H_VEPU		425992
+#define SRST_A_VEPU		425993
+#define SRST_CORE_VEPU		425994
+#define SRST_H_VEPU_PP		425995
+#define SRST_A_VEPU_PP		425996
+#define SRST_CORE_VEPU_DVBM	425997
+#define SRST_P_VICAP_VEPU	425998
+#define SRST_P_GPIO1		425999
+/********Name=VEPUSOFTRST_CON01,Offset=0x1AA04********/
+#define SRST_GPIO1		426000
+#define SRST_P_VEPU_IOC		426001
+#define SRST_P_SPI0		426002
+#define SRST_SPI0		426003
+#define SRST_P_VEPU_CRU		426005
+#define SRST_P_VEPU_SGRF	426006
+#define SRST_P_VEPU_GRF		426007
+#define SRST_UART_DETN_FLT	426008
+/********Name=VOSOFTRST_CON00,Offset=0x1CA00********/
+#define SRST_A_VO_BIU		458755
+#define SRST_H_VO_BIU		458756
+#define SRST_H_RGA2E		458759
+#define SRST_A_RGA2E		458760
+#define SRST_CORE_RGA2E		458761
+#define SRST_P_VO_GRF		458762
+#define SRST_A_VOP_BIU		458764
+#define SRST_H_VOP		458765
+#define SRST_D_VOP		458766
+#define SRST_A_VOP		458767
+/********Name=VOSOFTRST_CON01,Offset=0x1CA04********/
+#define SRST_P_MAC_BIU		458774
+#define SRST_A_MAC_BIU		458775
+#define SRST_A_MAC		458776
+#define SRST_P_VO_SGRF		458780
+#define SRST_P_VO_CRU		458781
+#define SRST_H_SDIO		458783
+/********Name=VOSOFTRST_CON02,Offset=0x1CA08********/
+#define SRST_P_TSADC		458784
+#define SRST_TSADC		458785
+#define SRST_P_OTPC_NS		458787
+#define SRST_SBPI_OTPC_NS	458789
+#define SRST_USER_OTPC_NS	458790
+#define SRST_P_OTPC_S		458791
+#define SRST_SBPI_OTPC_S	458793
+#define SRST_USER_OTPC_S	458794
+#define SRST_OTPC_ARB		458795
+#define SRST_MACPHY		458797
+#define SRST_P_OTP_MASK		458798
+#define SRST_PMC_OTP		458799
+/********Name=VOSOFTRST_CON03,Offset=0x1CA0C********/
+#define SRST_P_GPIO2		458800
+#define SRST_GPIO2		458801
+#define SRST_P_VO_IOC		458802
+/********Name=DDRSOFTRST_CON00,Offset=0x1EA00********/
+#define SRST_P_DDR_BIU		491522
+#define SRST_P_DDRC		491525
+#define SRST_P_DDRMON		491527
+#define SRST_TIMER_DDRMON	491528
+#define SRST_P_DFICTRL		491531
+#define SRST_A_SYS_SHRM		491533
+#define SRST_A_SHRM_NIU		491534
+#define SRST_P_DDR_GRF		491535
+/********Name=DDRSOFTRST_CON01,Offset=0x1EA04********/
+#define SRST_P_DDR_CRU		491536
+#define SRST_P_DDR_HWLP		491538
+#define SRST_P_DDRPHY		491539
+/********Name=SUBDDRSOFTRST_CON00,Offset=0x1FA00********/
+#define SRST_MSCH_BIU		507904
+#define SRST_A_DDRC		507905
+#define SRST_CORE_DDRC		507907
+#define SRST_DDRMON		507908
+#define SRST_DFICTRL		507909
+#define SRST_DDR_PHY		507910
+
+#endif
